import { AlertOutlined, AudioOutlined, BulbOutlined, CheckCircleOutlined, DashboardOutlined, ExperimentOutlined, FileImageOutlined, FileMarkdownOutlined, FormOutlined, PaperClipOutlined, ProfileOutlined, ReadOutlined, SafetyCertificateOutlined, SearchOutlined, SolutionOutlined } from '@ant-design/icons';
import { Button, Card, Col, Form, Input, InputNumber, Layout, Menu, message, Row, Select, Space } from 'antd';
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { useAuth } from '../../../../../contexts/AuthContext';
import { useInspectionSave } from '../../../../../hooks/useInspectionSave';
import { useOpenAI } from '../../../../../hooks/useOpenAI';
import { getOpenAIConfig } from '../../../../../utils/config';
import { ValidationResult } from '../../../core/base';
import { BaseGadget, GadgetConfig, GadgetContext, GadgetMetadata, GadgetSchema, GadgetType } from '../../base';
// Lazy imports declared below; remove direct imports to avoid conflicts
import { CheckboxWidget, ComboBoxWidget, DatePickerWidget, InputFieldWidget, RadioWidget, SignatureWidget, TagsInputWidget, TextAreaWidget, UploadWidget } from '../../../widgets/input';
import './AIAnalysisWizardGadget.css';
import type { AIAnalysisWizardConfig, AIAnalysisWizardData } from './AIAnalysisWizardGadget.types';
import { buildSummaryWidgets as buildGridSummaryWidgets, buildPromptText, clamp, coerceFieldValue, coerceNumber as coerceNumberUtil, convertInspectionToWizardData, getStableRestoreIdFromUrl, normalizeRestoredSections, normalizeVisionPromptConfig, tryFetchRecordFromApi, uniq } from './utils';

// Lazy-load heavy widgets to reduce initial bundle size
const VoiceRecorderWidget = React.lazy(() => import('../../../widgets/input/VoiceRecorderWidget').then(m => ({ default: m.VoiceRecorderWidget })));
const ImageUploadWithDrawingWidget = React.lazy(() => import('../../../widgets/input/ImageUploadWithDrawingWidget').then(m => ({ default: m.ImageUploadWithDrawingWidget })));
const PDFGeneratorWidget = React.lazy(() => import('../../../widgets/input/PDFGeneratorWidget').then(m => ({ default: m.PDFGeneratorWidget })));
const VisionAnalysisWidget = React.lazy(() => import('../../../widgets/input/VisionAnalysisWidget').then(m => ({ default: m.VisionAnalysisWidget })));
const SimpleAnalysisWidget = React.lazy(() => import('../../../widgets/input/SimpleAnalysisWidget').then(m => ({ default: (m as any).SimpleAnalysisWidget || (m as any).default })));
const EditableGridWidget = React.lazy(() => import('../../../widgets/input/EditableGridWidget').then(m => ({ default: m.EditableGridWidget })));

// helpers moved to ./utils

const { Option } = Select;
const { TextArea } = Input;

export class AIAnalysisWizardGadget extends BaseGadget {
  private currentStep: number = 0;
  private completedSteps: number[] = [];
  private wizardData: AIAnalysisWizardData = { currentStep: 0, completedSteps: [], sections: [], voiceData: {}, imageData: [], analysisData: {} };
  private config: AIAnalysisWizardConfig | null = null;
  private lastPropsHash: string = '';
  private persistedId: string | null = null;

  public metadata: GadgetMetadata = { id: 'ai-analysis-wizard', name: 'AI Analysis Wizard', description: 'Generic AI-powered inspection wizard with metadata-driven configuration', version: '1.0.0', author: 'intelliSPEC Team', category: 'forms', tags: ['wizard','ai','inspection','voice','image','analysis','markdown','generic'], gadgetType: GadgetType.FORM, widgetTypes: ['voice-recorder-widget','image-upload-with-drawing-widget','ai-analysis-widget'] };

  public schema: GadgetSchema = { type: 'object', properties: { currentStep: { type: 'number', minimum: 0 }, completedSteps: { type: 'array', items: { type: 'number' } }, inspectionType: { type: 'string' }, voiceData: { type: 'object' }, textData: { type: 'string' }, imageData: { type: 'array' }, analysisData: { type: 'object' } }, required: ['currentStep','completedSteps'], widgetSchemas: {} };

  constructor() { super(); this.setState({ data: this.wizardData }); }

  // Match DocumentFormGadget container behavior: remove base padding and allow full-height scroll
  public getContainerProps(props: any, context?: GadgetContext): any {
    const base = super.getContainerProps(props, context);
    return { ...base, noPadding: true };
  }

  private initializeConfig(props: any): void {
    const config = props.config || props.gadgetConfig || props;
    // Strict: build steps only if metadata provides sections/groups/fields per inspection metadata
    if (config && Array.isArray((config as any).sections) && Array.isArray((config as any).groups) && Array.isArray((config as any).fields)) {
      const { buildStepsFromFlat } = require('./utils/steps');
      const built = buildStepsFromFlat(config as any);
      this.config = { ...config, steps: built } as AIAnalysisWizardConfig;
    } else if (config && (config as any).steps) {
      this.config = { ...config } as AIAnalysisWizardConfig;
    }
  }

  // Removed unused initializeWizardData to satisfy linter

  public getRequiredWidgets(): string[] { return ['voice-recorder-widget','image-upload-with-drawing-widget','pdf-generator-widget']; }

  public validate(config: GadgetConfig): ValidationResult {
    const errors: string[] = []; const warnings: string[] = [];
    if (!this.config) { errors.push('Configuration is required'); return { isValid: false, errors, warnings }; }
    const hasSections = Array.isArray(this.config.steps.sections) && this.config.steps.sections.length > 0; if (!hasSections) errors.push('At least one section must be defined');
    if (this.config.steps.input) { const input = this.config.steps.input; if (!Array.isArray(input.inspectionTypes) || input.inspectionTypes.length === 0) { errors.push('Input step requires at least one inspection type'); } }
    if (!this.config.steps.pdf?.enabled) { errors.push('PDF generation step must be enabled'); }
    return { isValid: errors.length === 0, errors, warnings };
  }

  public getWidgetLayout(): any { return { type: 'grid', columns: 1, rows: 1, widgets: [{ id: 'ai-analysis-wizard-renderer', type: 'ai-analysis-wizard-renderer', position: { x: 0, y: 0, w: 1, h: 1 } }] }; }
  public processDataFlow(data: any): any { if (data.type === 'step_completed') { this.completeCurrentStep(); } else if (data.type === 'step_navigation') { this.navigateToStep(data.stepIndex); } else if (data.type === 'data_update') { this.updateWizardData(data.data); } return this.wizardData; }
  public getStepProgress(): number { const totalSteps = (this.config?.steps.sections?.length || 0) + 1 + (this.config?.steps.input ? 1 : 0); if (totalSteps <= 0) return 0; const clamped = Math.min(this.completedSteps.length, totalSteps); return (clamped / totalSteps) * 100; }
  public canNavigateToStep(stepIndex: number): boolean { return true; }
  public navigateToStep(stepIndex: number): void { this.currentStep = stepIndex; this.wizardData.currentStep = stepIndex; this.setState({ data: this.wizardData }); }
  public completeCurrentStep(): void { if (!this.completedSteps.includes(this.currentStep)) { this.completedSteps.push(this.currentStep); this.wizardData.completedSteps = [...this.completedSteps]; } const totalSteps = (this.config?.steps.sections?.length || 0) + 1 + (this.config?.steps.input ? 1 : 0); if (this.currentStep < totalSteps - 1) { this.navigateToStep(this.currentStep + 1); } this.setState({ data: this.wizardData }); }
  public updateWizardData(data: Partial<AIAnalysisWizardData>): void { this.wizardData = { ...this.wizardData, ...data }; this.setState({ data: this.wizardData }); }
  public getWizardData(): AIAnalysisWizardData { return this.wizardData; }
  public getWizardState(): any { return { currentStep: this.currentStep, completedSteps: this.completedSteps, progress: this.getStepProgress(), canNavigate: true, data: this.wizardData }; }

  public setPersistedId(id: string | null): void { this.persistedId = id; }
  public getPersistedId(): string | null { return this.persistedId; }

  public renderBody(props: any, context?: GadgetContext): React.ReactNode {
    const propsHash = JSON.stringify(props);
    if (!this.config || this.lastPropsHash !== propsHash) { this.initializeConfig(props); this.lastPropsHash = propsHash; }
    if (!this.config) return <div>Configuration is required</div>;
    return <GenericWizardRenderer gadget={this} config={this.config} />;
  }
}

interface AIAnalysisWizardRendererProps { gadget: AIAnalysisWizardGadget; config: AIAnalysisWizardConfig; }

const GenericWizardRenderer: React.FC<AIAnalysisWizardRendererProps> = ({ gadget, config }) => {
  const { user } = useAuth();

  // State for dynamic options loading
  const [fieldOptions, setFieldOptions] = React.useState<Record<string, Array<{label: string, value: any}>>>({});
  const [loadingOptions, setLoadingOptions] = React.useState<Record<string, boolean>>({});

  // Use useRef to track previous field values without causing re-renders
  const prevFieldValuesRef = React.useRef<Record<string, any>>({});
  const prevWizardDataRef = React.useRef<any>(null);

  // Load options for fields with optionsUrl
  const loadFieldOptions = React.useCallback(async (fieldId: string, field: any, forceReload = false) => {
    if (!field?.optionsUrl || (!forceReload && fieldOptions[fieldId])) return;

    setLoadingOptions(prev => ({ ...prev, [fieldId]: true }));

    try {
      // Build URL with query parameters for dependent fields
      let url = field.optionsUrl;
      const urlParams = new URLSearchParams();

      // Add dependent filter values as query parameters
      const dependencies = Array.isArray(field.dependsOn) ? field.dependsOn : (field.dependsOn ? [field.dependsOn] : []);

      dependencies.forEach((depId: string) => {
        const parentValue = getFormFieldValue(depId);
        if (parentValue !== undefined && parentValue !== '') {
          if (Array.isArray(parentValue)) {
            parentValue.forEach(val => urlParams.append(depId, val));
          } else {
            urlParams.append(depId, parentValue);
          }
        }
      });

      // Add query parameters to URL if any exist
      if (urlParams.toString()) {
        url += (url.includes('?') ? '&' : '?') + urlParams.toString();
      }

      const response = await BaseGadget.makeAuthenticatedFetch(url);
      const data = await response.json();

      // Handle different response formats
      let options: Array<{ label: string; value: any }> = [];

      if (Array.isArray(data)) {
        options = data.map((item: any) => ({
          label: field.labelField ? item[field.labelField] : (item.label || item.name || item.title || String(item.value || item)),
          value: field.valueField ? item[field.valueField] : (item.value || item.id || item)
        }));
      } else if (data.options && Array.isArray(data.options)) {
        options = data.options.map((item: any) => ({
          label: field.labelField ? item[field.labelField] : (item.label || item.name || item.title || String(item.value || item)),
          value: field.valueField ? item[field.valueField] : (item.value || item.id || item)
        }));
      } else if (data.data && Array.isArray(data.data)) {
        options = data.data.map((item: any) => ({
          label: field.labelField ? item[field.labelField] : (item.label || item.name || item.title || String(item.value || item)),
          value: field.valueField ? item[field.valueField] : (item.value || item.id || item)
        }));
      }

      setFieldOptions(prev => ({ ...prev, [fieldId]: options }));
    } catch (error) {
      console.error(`Failed to load options for field ${fieldId}:`, error);
    } finally {
      setLoadingOptions(prev => ({ ...prev, [fieldId]: false }));
    }
  }, [fieldOptions]);

  // Load options for all fields with optionsUrl on mount
  React.useEffect(() => {
    if (!config?.steps?.sections) return;

    const fieldsWithOptions: Array<{fieldId: string, field: any}> = [];

    // Find all fields with optionsUrl
    for (const section of config.steps.sections) {
      if (section?.form?.groups) {
        for (const group of section.form.groups) {
          if (group?.fields) {
            for (const field of group.fields) {
              if (field?.optionsUrl && field?.id) {
                fieldsWithOptions.push({ fieldId: field.id, field });
              }
            }
          }
        }
      }
    }

    // Load options for independent fields first
    fieldsWithOptions.forEach(({ fieldId, field }) => {
      if (!field.dependsOn) {
        loadFieldOptions(fieldId, field);
      }
    });
  }, [config?.steps?.sections, loadFieldOptions]);

  // Initialize previous field values on mount
  React.useEffect(() => {
    if (!config?.steps?.sections) return;

    const initialValues: Record<string, any> = {};
    const allFields: Array<{fieldId: string, field: any}> = [];

    // Find all fields
    for (const section of config.steps.sections) {
      if (section?.form?.groups) {
        for (const group of section.form.groups) {
          if (group?.fields) {
            for (const field of group.fields) {
              if (field?.id) {
                allFields.push({ fieldId: field.id, field });
              }
            }
          }
        }
      }
    }

    // Initialize with current values
    allFields.forEach(({ fieldId }) => {
      initialValues[fieldId] = getFormFieldValue(fieldId);
    });

    prevFieldValuesRef.current = initialValues;
  }, [config?.steps?.sections]);

  // Detect form field changes and reload dependent options
  React.useEffect(() => {
    if (!config?.steps?.sections) return;

    const currentWizardData = gadget.getWizardData();
    const prevWizardData = prevWizardDataRef.current;

    // Only run if wizard data has actually changed
    if (JSON.stringify(prevWizardData) === JSON.stringify(currentWizardData)) {
      return;
    }

    prevWizardDataRef.current = currentWizardData;

    const changedFields: string[] = [];

    // Find all fields with form data
    const allFields: Array<{fieldId: string, field: any}> = [];
    for (const section of config.steps.sections) {
      if (section?.form?.groups) {
        for (const group of section.form.groups) {
          if (group?.fields) {
            for (const field of group.fields) {
              if (field?.id) {
                allFields.push({ fieldId: field.id, field });
              }
            }
          }
        }
      }
    }

    // Detect which fields have actually changed
    allFields.forEach(({ fieldId, field }) => {
      const currentValue = getFormFieldValue(fieldId);
      const prevValue = prevFieldValuesRef.current[fieldId];

      if (JSON.stringify(currentValue) !== JSON.stringify(prevValue)) {
        changedFields.push(fieldId);
      }
    });

    // Also check for fields that were cleared
    Object.keys(prevFieldValuesRef.current).forEach(fieldId => {
      if (getFormFieldValue(fieldId) === undefined && prevFieldValuesRef.current[fieldId] !== undefined) {
        changedFields.push(fieldId);
      }
    });

    // Reload dependent fields when their parent changes
    if (changedFields.length > 0) {
      allFields.forEach(({ fieldId, field }) => {
        if (field?.dependsOn) {
          const dependencies = Array.isArray(field.dependsOn) ? field.dependsOn : [field.dependsOn];
          const hasChangedDependency = dependencies.some((depId: string) => changedFields.includes(depId));

          if (hasChangedDependency) {
            // Clear options and reload
            setFieldOptions(prev => {
              const next = { ...prev };
              delete next[fieldId];
              return next;
            });
            loadFieldOptions(fieldId, field, true);
          }
        }
      });

      // Update previous values
      const newPrevValues: Record<string, any> = {};
      allFields.forEach(({ fieldId }) => {
        newPrevValues[fieldId] = getFormFieldValue(fieldId);
      });
      prevFieldValuesRef.current = newPrevValues;
    }
  }, [config?.steps?.sections, loadFieldOptions]);

  // Helper function to get form field value from wizard data
  const getFormFieldValue = (fieldId: string): any => {
    // Search through all sections for the field value
    const wizardData = gadget.getWizardData();
    if (wizardData?.sections) {
      for (const section of wizardData.sections) {
        if (section?.formData && typeof section.formData === 'object' && section.formData[fieldId] !== undefined) {
          return section.formData[fieldId];
        }
      }
    }
    return undefined;
  };

  // Helper function to get dependent fields for a given field ID
  const getDependentFields = (fieldId: string): string[] => {
    const dependentFields: string[] = [];
    if (!config?.steps?.sections) return dependentFields;

    for (const section of config.steps.sections) {
      if (section?.form?.groups) {
        for (const group of section.form.groups) {
          if (group?.fields) {
            for (const field of group.fields) {
              if (field?.dependsOn === fieldId) {
                dependentFields.push(field.id);
              }
            }
          }
        }
      }
    }
    return dependentFields;
  };

  // Helper function to get logged-in user's full name
  const getLoggedInUserName = () => {
    if (user && user.firstName && user.lastName) {
      return `${user.firstName} ${user.lastName}`;
    }
    if (user && user.email) {
      // Fallback to email if name not available
      return user.email.split('@')[0]; // Use part before @ symbol
    }
    return null; // Will fall back to 'Unknown User'
  };
  
  useEffect(() => {
    let cancelled = false;
    const restore = async () => {
      try {
        // 1) Prefer explicit initialData passed via config
        const initialData = (config as any)?.initialData as Partial<AIAnalysisWizardData> | undefined;
        if (initialData && !cancelled) {
          let normalizedSections = normalizeRestoredSections(config, initialData.sections as any);
          const totalSteps = (config.steps.sections?.length || 0) + 1 + (config.steps.input ? 1 : 0);
          const safeCurrent = clamp(Number((initialData as any).currentStep || 0), 0, Math.max(0, totalSteps));
          const safeCompleted = uniq((Array.isArray((initialData as any).completedSteps) ? (initialData as any).completedSteps : []).map((n: any) => Number(n)).filter((n: number) => Number.isFinite(n) && n >= 0 && n <= totalSteps));
          // Clear response ID from restored data to start fresh conversation
        const analysisData = { ...((initialData as any).analysisData || {}) };
        delete analysisData.previousResponseId;
        
        const restored = { currentStep: safeCurrent, completedSteps: safeCompleted, sections: normalizedSections, voiceData: (initialData as any).voiceData || {}, imageData: (initialData as any).imageData || [], analysisData } as AIAnalysisWizardData;
          gadget.updateWizardData(restored);
          if (!cancelled) { setWizardData(gadget.getWizardData()); setCurrentStep(restored.currentStep); }
          return;
        }

        // 2) Try to restore from API only (single source of truth)
        const id = getStableRestoreIdFromUrl();
        if (!id) return;

        let payload: any | null = await tryFetchRecordFromApi(id);
        if (!payload) return;

        // Check if this is inspection data (has different structure than wizard data)
        const isInspectionData = payload.type === 'inspection' || payload.id?.startsWith('inspection-');

        let wizardDataFromPayload: any;
        let normalizedSections: any;

        if (isInspectionData) {
          // Convert inspection data to wizard format
          wizardDataFromPayload = convertInspectionToWizardData(payload);
          normalizedSections = wizardDataFromPayload.sections || [];
        } else {
          // Handle wizard progress data (existing logic)
          if (!payload.data) return;
          wizardDataFromPayload = payload.data;
          normalizedSections = normalizeRestoredSections(config, payload.data.sections);
        }

        const totalSteps = (config.steps.sections?.length || 0) + 1 + (config.steps.input ? 1 : 0);
        const safeCurrent = clamp(Number(wizardDataFromPayload.currentStep || 0), 0, Math.max(0, totalSteps));
        const safeCompleted = uniq((Array.isArray(wizardDataFromPayload.completedSteps) ? wizardDataFromPayload.completedSteps : []).map((n: any) => Number(n)).filter((n: number) => Number.isFinite(n) && n >= 0 && n <= totalSteps));
        // Clear response ID from restored data to start fresh conversation
        const analysisData = { ...(wizardDataFromPayload.analysisData || {}) };
        delete analysisData.previousResponseId;

        const restored = {
          currentStep: safeCurrent,
          completedSteps: safeCompleted,
          sections: normalizedSections,
          voiceData: wizardDataFromPayload.voiceData || {},
          imageData: wizardDataFromPayload.imageData || [],
          analysisData
        } as AIAnalysisWizardData;

        gadget.updateWizardData(restored);
        gadget.setPersistedId(payload.id || id);

        // Set inspection ID if loading existing inspection
        if (isInspectionData && payload.id) {
          setInspectionId(payload.id);
        }

        if (!cancelled) { setWizardData(gadget.getWizardData()); setCurrentStep(restored.currentStep); }
      } catch {}
    };
    restore();
    return () => { cancelled = true; };
  }, []);

  const [currentStep, setCurrentStep] = useState(0);
  const [wizardData, setWizardData] = useState<AIAnalysisWizardData>(gadget.getWizardData());
  const sections = config.steps.sections || [];

  const updateSectionData = useCallback((sectionIndex: number, update: Partial<NonNullable<AIAnalysisWizardData['sections']>[number]> & { formData?: Record<string, any> }) => {
    const next = { ...(gadget.getWizardData()) } as AIAnalysisWizardData;
    next.sections = next.sections || [];
    const base = next.sections[sectionIndex] || { id: sections[sectionIndex].id, title: sections[sectionIndex].title } as any;
    next.sections[sectionIndex] = { ...base, ...update } as any;
    gadget.updateWizardData(next);
    setWizardData(gadget.getWizardData());
  }, [gadget, sections]);


  const openAI = useOpenAI(getOpenAIConfig());

  // Convert images to base64 data URLs for OpenAI
  const getImagesForOpenAI = (): { url: string }[] => {
    const images: any[] = [];

    // Collect images from all sections and main imageData
    sections.forEach((section, index) => {
      const sectionData = (wizardData.sections || [])[index] || {};
      const sectionImages = ((sectionData as any).images || []) as any[];
      images.push(...sectionImages);
    });

    // Also include main imageData
    if (wizardData.imageData && wizardData.imageData.length > 0) {
      images.push(...wizardData.imageData);
    }

    // Convert to OpenAI format (base64 data URLs)
    const validImages = images.map(img => {
      if (img.drawingData && img.drawingData.startsWith('data:')) {
        // Already a data URL
        return { url: img.drawingData };
      } else if (img.url && img.url.startsWith('http')) {
        // Convert HTTP URL to base64 data URL
        // For now, just return the URL - the component will handle conversion when needed
        return { url: img.url };
      }
      return null;
    }).filter(img => img !== null) as { url: string }[];

    return validImages;
  };

  const SectionImageAnalysis: React.FC<{ sectionIndex: number }> = React.memo(({ sectionIndex }) => {
    const section = sections[sectionIndex];
    const data = (wizardData.sections || [])[sectionIndex] || {};
    let sourceImages = ((data as any).images || []) as any[];
    // Allow analysis section to reference images strictly from configured sources
    try {
      const promptSourceIds = Array.isArray((section as any)?.promptSourceIds) ? (section as any)?.promptSourceIds as string[] : [];
      let srcIdx = -1;
      // Prefer promptSourceIds if provided
      if ((sourceImages == null || sourceImages.length === 0) && promptSourceIds.length > 0) {
        for (const sid of promptSourceIds) {
          const idx = (sections || []).findIndex((s) => (s as any)?.id === sid);
          if (idx >= 0) {
            const srcData = (wizardData.sections || [])[idx] || {};
            const imgs = ((srcData as any).images || []) as any[];
            if (imgs && imgs.length > 0) { srcIdx = idx; break; }
          }
        }
      }
      // legacy imageSourceSectionId mapping removed
      if (srcIdx >= 0) {
        const srcData = (wizardData.sections || [])[srcIdx] || {};
        sourceImages = ((srcData as any).images || []) as any[];
      }
    } catch {}

    // Fallback: If no images found in sections, use the main imageData from the widget
    if ((!sourceImages || sourceImages.length === 0) && wizardData.imageData && wizardData.imageData.length > 0) {
      sourceImages = wizardData.imageData;
    }

    // Images are converted to base64 at the parent component level

    const images = (sourceImages || []).map((img: any) => ({
      url: img.url,
      name: img.name,
      drawingData: img.drawingData
    }));

    const hasImages = (images || []).length > 0;
    
    // Debug: Log image information
    try {
      console.debug('[SectionImageAnalysis] Images debug:', {
        sectionId: section?.id,
        promptSourceIds: (section as any)?.promptSourceIds,
        sourceImagesCount: sourceImages?.length || 0,
        finalImagesCount: images?.length || 0,
        imageUrls: images?.map((img: any) => img.url?.slice(0, 50) + '...') || []
      });

      // Additional guidance for OpenAI image usage
      if (images?.length > 0) {
        console.info(`ðŸ“¸ [SectionImageAnalysis] Found ${images.length} images, will be converted to base64 for OpenAI`);
      }
    } catch {}
    // Build a combined transcript/text context from voice + notes across the wizard
    const combinedText = (() => {
      try {
        return [
          (wizardData as any)?.voiceData?.transcription || '',
          (wizardData as any)?.textData || '',
          ...((wizardData.sections || []).flatMap(s => [((s as any)?.voiceData?.transcription) || '', ((s as any)?.textData) || '']))
        ].filter(Boolean).join('\n\n');
      } catch { return (data as any).textData || ''; }
    })();
    const analysisWidgetType = String((section as any)?.analysisWidget || 'vision');
    
    // Debug logging to help diagnose widget selection
    try {
      console.debug('[SectionImageAnalysis] Widget selection debug:', {
        sectionId: section?.id,
        sectionTitle: section?.title,
        analysisWidgetFromSection: (section as any)?.analysisWidget,
        finalAnalysisWidgetType: analysisWidgetType,
        sectionKeys: Object.keys(section || {})
      });
    } catch {}
    return (
      <React.Suspense fallback={<div style={{ padding: 8, color: 'hsl(var(--muted-foreground))' }}>Loading analysis...</div>}>
      {analysisWidgetType === 'simple'
        ? React.createElement(SimpleAnalysisWidget as any, {
            title: (section as any).imageAnalysisPrompt?.title || section.title || 'AI Analysis',
            images,
            text: combinedText,
            promptConfig: (section as any).imageAnalysisPrompt as any,
            mockDataUrl: (section as any)?.mockDataUrl,
            initialResult: ((wizardData.sections || [])[sectionIndex]?.imageAnalysis) as any,
            initialSelection: ((wizardData.sections || [])[sectionIndex]?.imageAnalysis?.selectedSuggestionIds) || [],
            previousResponseId: (wizardData.analysisData as any)?.previousResponseId || null,
            onResult: (res: any) => {
              const next: any = { imagesCollapsed: true, imageAnalysis: { overview: res.overview, suggestions: (res as any).items || (res as any).suggestions || [], selectedSuggestionIds: res.selectedIds || [] } };
              
              // Extract equipment type from analysis text and auto-populate the field
              try {
                const analysisText = (res.overview || '').toLowerCase();
                let detectedType = 'other';
                
                console.debug('[Equipment Type Detection] Analysis text:', {
                  fullText: res.overview,
                  lowercaseText: analysisText,
                  textLength: analysisText.length,
                  // Pressure vessel keywords
                  containsPressureVessel: analysisText.includes('pressure vessel'),
                  containsPressureTank: analysisText.includes('pressure tank'),
                  containsVessel: analysisText.includes('vessel'),
                  containsReactor: analysisText.includes('reactor'),
                  containsBoiler: analysisText.includes('boiler'),
                  // Storage tank keywords
                  containsStorageTank: analysisText.includes('storage tank'),
                  containsAtmosphericTank: analysisText.includes('atmospheric tank'),
                  containsTank: analysisText.includes('tank'),
                  // Piping keywords
                  containsPiping: analysisText.includes('piping'),
                  containsPipe: analysisText.includes('pipe'),
                  containsPipeline: analysisText.includes('pipeline'),
                  containsPipingSystem: analysisText.includes('piping system'),
                  // Relief device keywords
                  containsRelief: analysisText.includes('relief'),
                  containsSafetyValve: analysisText.includes('safety valve'),
                  containsPrv: analysisText.includes('prv')
                });
                
                // More specific patterns first, then general patterns
                if (analysisText.includes('pressure vessel') || analysisText.includes('pressure tank') || analysisText.includes('reactor') || analysisText.includes('boiler')) {
                  detectedType = 'pressure_vessel';
                } else if (analysisText.includes('storage tank') || analysisText.includes('atmospheric tank') || analysisText.includes('silo')) {
                  detectedType = 'storage_tank';
                } else if (analysisText.includes('piping') || analysisText.includes('pipe') || analysisText.includes('pipeline') || analysisText.includes('piping system')) {
                  detectedType = 'piping';
                } else if (analysisText.includes('relief') || analysisText.includes('safety valve') || analysisText.includes('rupture disc') || analysisText.includes('prv')) {
                  detectedType = 'relief_device';
                } else if (analysisText.includes('heat exchanger') || analysisText.includes('exchanger')) {
                  detectedType = 'heat_exchanger';
                } else if (analysisText.includes('vessel') || analysisText.includes('tank')) {
                  // Generic fallback for vessels/tanks - default to pressure vessel if no specific type found
                  detectedType = 'pressure_vessel';
                }
                
                // Find the general information section and update the detected equipment type
                const generalInfoSectionIndex = sections.findIndex(s => s.id === 'general_information');
                if (generalInfoSectionIndex >= 0) {
                  const generalInfoData = wizardData.sections?.[generalInfoSectionIndex]?.formData || {};
                  updateSectionData(generalInfoSectionIndex, {
                    formData: {
                      ...generalInfoData,
                      detected_equipment_type: detectedType
                    }
                  });
                  
                  console.debug('[Equipment Type Detection]', {
                    detectedType,
                    sectionIndex: generalInfoSectionIndex,
                    previousValue: generalInfoData.detected_equipment_type,
                    updatedFormData: {
                      ...generalInfoData,
                      detected_equipment_type: detectedType
                    },
                    triggerType: 'AI_ANALYSIS'
                  });
                  
                  // Force wizard data update to trigger conditional section refresh
                  setTimeout(() => {
                    setWizardData(gadget.getWizardData());
}, 100);
                }
              } catch (err) {
                console.error('[Equipment Type Detection] Failed:', err);
              }
              
              try {
                if (res.responseId) {
                  (window as any).__previousResponseId = res.responseId;
                  gadget.updateWizardData({ analysisData: { ...((wizardData as any).analysisData || {}), previousResponseId: res.responseId } });
                  setWizardData(gadget.getWizardData());
                }
              } catch {}
              updateSectionData(sectionIndex, next);
            }
          })
        : (
        <VisionAnalysisWidget
          id={`vision-${sectionIndex}`}
          title={(section as any).imageAnalysisPrompt?.title || section.title || 'AI Vision Analysis'}
          images={images}
          text={combinedText}
          promptConfig={(section as any).imageAnalysisPrompt as any}
          initialResult={((wizardData.sections || [])[sectionIndex]?.imageAnalysis) as any}
          initialSelection={((wizardData.sections || [])[sectionIndex]?.imageAnalysis?.selectedSuggestionIds) || []}
          compactDefault={false}
          onResult={(res) => { updateSectionData(sectionIndex, { imagesCollapsed: true, imageAnalysis: { overview: res.overview, suggestions: res.suggestions as any, selectedSuggestionIds: res.selectedSuggestionIds } }); }}
        />
      )}
        {!hasImages && (
          <div style={{ marginTop: 8, color: 'hsl(var(--muted-foreground))' }}>No images detected for analysis. Please upload images in the Image Capture step.</div>
        )}
      </React.Suspense>
    );
  });

  const renderSectionStep = (sectionIndex: number) => {
    const section = sections[sectionIndex];
    const data = (wizardData.sections || [])[sectionIndex] || {};
    // Removed custom resourcesGrid logic - now uses standard grid pattern

    return (
      <Card
        className="glass-card wizard-card"
        title={<Space direction="vertical" size={0} style={{ width: '100%' }}><span style={{ display: 'flex', alignItems: 'center', gap: 8 }}>{getIconForSection(section)}<span>{section.title}</span></span>{section.description && (<span style={{ fontSize: 12, opacity: 0.8 }}>{section.description}</span>)}</Space>}
        extra={(() => {
          const extras: React.ReactNode[] = [];
          // Form populate
          const populateCfg = {
            enabled: true,
            label: (section as any)?.btnLabel,
            promptRef: (section as any)?.promptRef,
            promptSourceIds: (section as any)?.promptSourceIds
          } as any;
          if ((section as any)?.form?.groups?.length && populateCfg && populateCfg.enabled !== false) {
            const handlePopulateForm = async () => {
              try {
                let imageOverview = '';
                try {
                  const ids: string[] = Array.isArray(populateCfg.promptSourceIds) ? populateCfg.promptSourceIds : [];
                  for (const sid of ids) {
                    const idx = (sections || []).findIndex(s => (s as any)?.id === sid);
                    if (idx >= 0) {
                      const ov = String(((wizardData.sections || [])[idx] as any)?.imageAnalysis?.overview || '');
                      if (ov) { imageOverview = ov; break; }
                    }
                  }
                } catch {}
                const fieldsList: Array<any> = (section.form?.groups || []).flatMap(g => (g as any).fields || []);
                const schemaFields: Record<string, any> = {}; const fieldsMeta: Array<any> = [];
                for (const f of fieldsList) { const t = String((f as any).type || '').toLowerCase(); const e: any = { id: (f as any).id, type: t, required: Boolean((f as any).required) }; if (Array.isArray((f as any).options)) e.options = (f as any).options; fieldsMeta.push(e); if (t === 'number') schemaFields[(f as any).id] = 0; else if (t === 'checkbox_group' || t === 'multi-select') schemaFields[(f as any).id] = []; else schemaFields[(f as any).id] = ''; }
                const promptKey = String(populateCfg.promptRef || 'deepAnalysis'); const deep = ((config as any)?.prompts?.[promptKey]); if (!deep || !deep.promptConfig) return;
                // Auto-generate a prompt if none provided or autoPrompt is enabled
                const userTemplateRaw = String(deep.promptConfig.userPrompt || '');
                const autoTemplate = () => {
                  const fieldIds = (fieldsList || []).map((f: any) => String(f.id));
                  const fieldConstraints = fieldsMeta
                    .filter((f: any) => f.options && Array.isArray(f.options) && f.options.length > 0)
                    .map((f: any) => `${f.id}: must be one of ${JSON.stringify(f.options)}`)
                    .join(', ');
                  
                  return [
                    'Using the current conversation state, populate the following form fields.',
                    `Return ONLY a JSON object with EXACT keys: ${JSON.stringify(fieldIds)}.`,
                    fieldConstraints ? `Field constraints: ${fieldConstraints}.` : '',
                    'Rules: use "N/A" for unknown strings and 0 for unknown numbers; for dropdown/checkbox fields, use only the exact values from the provided options; do not invent data beyond conversation state.',
                  ].filter(Boolean).join('\n');
                };
                const templateToUse = (!userTemplateRaw || (deep as any)?.autoPrompt === true) ? autoTemplate() : userTemplateRaw;
                // Provide minimal hints to encourage filling unknowns; echo exact field ids
                const filledUser = buildPromptText(templateToUse, { mapping: (deep as any)?.mapping, context: { schema_fields_json: schemaFields, fields_meta_json: fieldsMeta, field_ids: Object.keys(schemaFields), fill_unknown_with: 'N/A', image_analysis_overview: imageOverview } });
                const transcript = [
                  wizardData.voiceData?.transcription || '',
                  wizardData.textData || '',
                  ...((wizardData.sections || []).flatMap(s => [((s as any)?.voiceData?.transcription) || '', ((s as any)?.textData) || '']))
                ].filter(Boolean).join('\n\n');
                
                // Build context for AI - keep it simple since conversation is stateful
                const contextText = filledUser; // AI has conversation history via previous_response_id
                const prevId = (wizardData as any)?.analysisData?.previousResponseId || (window as any)?.__previousResponseId;
                
                // Debug: Log the context being sent to AI
                try {
                  // Check if we have any analysis data available as fallback
                  let imageAnalysisText = '';
                  try {
                    const ids: string[] = Array.isArray(populateCfg.promptSourceIds) ? populateCfg.promptSourceIds : [];
                    for (const sid of ids) {
                      const idx = (sections || []).findIndex(s => (s as any)?.id === sid);
                      if (idx >= 0) {
                        const ov = String(((wizardData.sections || [])[idx] as any)?.imageAnalysis?.overview || '');
                        if (ov) { imageAnalysisText = ov; break; }
                      }
                    }
                  } catch {}
                  
                  console.debug('[Form Populate] Stateful request:', {
                    sectionId: section.id,
                    promptKey,
                    hasConversationHistory: Boolean(prevId),
                    previousResponseId: prevId,
                    contextLength: contextText.length,
                    usingStatefulConversation: true,
                    wizardAnalysisDataResponseId: (wizardData as any)?.analysisData?.previousResponseId,
                    globalResponseId: (window as any)?.__previousResponseId,
                    hasImageAnalysisData: Boolean(imageAnalysisText),
                    imageAnalysisLength: imageAnalysisText.length
                  });
                  
                  // If no conversation history but we have analysis data, include it as fallback
                  if (!prevId && imageAnalysisText && promptKey === 'generalInfoPopulate') {
                    console.warn('[Form Populate] No conversation history - falling back to include analysis text');
                    const contextWithAnalysis = `PREVIOUS IMAGE ANALYSIS:\n${imageAnalysisText}\n\nFORM FIELDS TO POPULATE:\n${contextText}`;
                    const response = await openAI.respond({
                      modelConfig: { ...(deep?.modelConfig as any) || {}, maxCompletionTokens: Math.max(((deep?.modelConfig as any)?.maxCompletionTokens ?? 0), 2000) },
                      promptConfig: {
                        systemPrompt: deep?.promptConfig?.systemPrompt || '',
                        userPrompt: '{text}'
                      },
                      text: contextWithAnalysis,
                      images: getImagesForOpenAI(), // Send images directly as data URLs
                      store: true,
                      responseFormat: 'json',
                      reasoningEffort: 'low'
                    });
                    let result: any = response.data || {}; 
                    if (typeof result === 'string') { try { result = JSON.parse(result); } catch {} }
                    
                    // Save the new response ID for future calls
                    if ((response as any)?.responseId) {
                      (window as any).__previousResponseId = (response as any).responseId;
}
                    
                    // Apply the result and return early
                    if (result && typeof result === 'object' && Object.keys(result).length > 0) {
                      // Apply valid results to form
                      Object.entries(result).forEach(([key, value]) => {
                        if (typeof value === 'string' || typeof value === 'number') {
                          const currentIdx = (wizardData.sections || []).findIndex(s => s.id === section.id);
                          const sectionData = wizardData.sections?.[currentIdx];
                          if (sectionData && (sectionData as any).formData) {
                            (sectionData as any).formData[key] = value;
                          }
                        }
                      });
                      setWizardData({ ...wizardData });
                      message.success('Form populated with analysis data');
                      return;
                    }
                  }
                } catch {}

                // Skip conversation history for structured JSON generation to avoid conflicts
                const skipHistory = (deep as any)?.autoPrompt === true || (promptKey && typeof promptKey === 'string' && promptKey.includes('Populate'));

                const response = await openAI.respond({
                  modelConfig: { ...(deep?.modelConfig as any) || {}, maxCompletionTokens: Math.max(((deep?.modelConfig as any)?.maxCompletionTokens ?? 0), 2000) },
                  promptConfig: { systemPrompt: (deep as any)?.promptConfig?.systemPrompt || '', userPrompt: '{text}' },
                  text: contextText,
                  images: getImagesForOpenAI(), // Send images directly as data URLs
                  store: true,
                  previousResponseId: skipHistory ? undefined : (typeof prevId === 'string' ? prevId : undefined),
                  responseFormat: 'json',
                  reasoningEffort: 'low'
                });
                let result: any = response.data || {}; if (typeof result === 'string') { try { result = JSON.parse(result); } catch {} }
                // If response incomplete due to token cap, retry once with continuation
                if ((response as any)?.raw?.incomplete_details?.reason === 'max_output_tokens') {
                  try {
                    const missingFields = (fieldsList || []).map((f:any)=>String(f.id)).filter((fid) => !(fid in (result || {})));
                    const continueText = [
                      'Continue the previous response by filling ONLY the remaining fields.',
                      `Missing fields: ${JSON.stringify(missingFields)}.`,
                      'Return a single JSON object with those keys only.'
                    ].join(' ');
                    const cont = await openAI.respond({
                      modelConfig: { ...(deep?.modelConfig as any) || {}, maxCompletionTokens: Math.max(((deep?.modelConfig as any)?.maxCompletionTokens ?? 0), 1500) },
                      promptConfig: { systemPrompt: deep?.promptConfig?.systemPrompt || '', userPrompt: '{text}' },
                      text: continueText,
                      images: getImagesForOpenAI(), // Send images directly as data URLs for continuation
                      store: true,
                      previousResponseId: skipHistory ? undefined : ((response as any)?.responseId || prevId),
                      responseFormat: 'json',
                      reasoningEffort: 'high'
                    });
                    let contObj: any = cont.data || {};
                    if (typeof contObj === 'string') { try { contObj = JSON.parse(contObj); } catch {} }
                    if (contObj && typeof contObj === 'object') {
                      result = { ...(result || {}), ...contObj };
                    }
                  } catch {}
                }
                if (!result || Object.keys(result).length === 0) { const raw = (response as any)?.rawText || ''; const match = raw.match(/\{[\s\S]*\}/); if (match) { try { result = JSON.parse(match[0]); } catch {} } }
                // Retry once with minimal state hint if still empty
                if (!result || (typeof result === 'object' && Object.keys(result).length === 0)) {
                  try {
                    const fieldIds = (fieldsList || []).map((f:any)=>String(f.id));
                    const fieldConstraints = fieldsMeta
                      .filter((f: any) => f.options && Array.isArray(f.options) && f.options.length > 0)
                      .map((f: any) => `${f.id}: must be one of ${JSON.stringify(f.options)}`)
                      .join(', ');
                      
                    const retryTemplate = [
                      'Using the current conversation state, populate the following form fields.',
                      `Return ONLY a JSON object with EXACT keys: ${JSON.stringify(fieldIds)}.`,
                      fieldConstraints ? `Field constraints: ${fieldConstraints}.` : '',
                      'Rules: use "N/A" for unknown strings and 0 for unknown numbers; for dropdown/checkbox fields, use only the exact values from the provided options; do not invent data.',
                      imageOverview ? `Context (image_overview): ${imageOverview}` : ''
                    ].filter(Boolean).join('\n');
                    const retryText = buildPromptText(retryTemplate, { mapping: (deep as any)?.mapping, context: { schema_fields_json: schemaFields } });
                    const retryResp = await openAI.respond({ modelConfig: { ...(deep?.modelConfig as any) || {}, maxCompletionTokens: Math.max(((deep?.modelConfig as any)?.maxCompletionTokens ?? 0), 2000) }, promptConfig: { systemPrompt: deep?.promptConfig?.systemPrompt || '', userPrompt: '{text}' }, text: retryText, store: true, previousResponseId: skipHistory ? undefined : ((response as any)?.responseId || prevId), responseFormat: 'json', reasoningEffort: 'low' });
                    result = retryResp.data || {};
                    if (typeof result === 'string') { try { result = JSON.parse(result); } catch {} }
                  } catch {}
                }
                if (!result || typeof result !== 'object') { 
return; 
                }
                // Validate result keys vs form fields
                try {
                  const fieldIds: string[] = fieldsList.map((f: any) => String(f.id));
                  const resultKeys: string[] = Object.keys(result as any);
                  const missingIds = fieldIds.filter(id => !(id in (result as any)));
                  const extraKeys = resultKeys.filter(k => !fieldIds.includes(k));
                  const filledCount = fieldIds.length - missingIds.length;
                  
                  console.debug('[Form Populate] Field mapping:', {
                    expectedFieldIds: fieldIds,
                    receivedKeys: resultKeys,
                    missingIds,
                    extraKeys,
                    result
                  });
                  
                  message.info(`AI populated ${filledCount}/${fieldIds.length} fields${missingIds.length ? `, missing: ${missingIds.slice(0,5).join(', ')}${missingIds.length>5 ? 'â€¦' : ''}` : ''}`);
                } catch {}
                const nextForm: Record<string, any> = { ...((data as any).formData || {}) };
                
                console.debug('[Form Populate] Processing field mapping:', {
                  beforeUpdate: nextForm,
                  resultData: result
                });
                
                for (const f of fieldsList) { 
                  const fid = (f as any).id; 
                  if (!(fid in result)) continue; 
                  const fType = String((f as any).type || '').toLowerCase(); 
                  const rawValue = (result as any)[fid];
                  const v = coerceFieldValue(fType, rawValue, Array.isArray((f as any).options) ? (f as any).options : undefined); 
if (v !== undefined) nextForm[fid] = v; 
                }
updateSectionData(sectionIndex, { formData: nextForm });
                try {
                  if (response.responseId) {
                    (window as any).__previousResponseId = response.responseId;
                    gadget.updateWizardData({ analysisData: { ...((wizardData as any).analysisData || {}), previousResponseId: response.responseId } });
                    setWizardData(gadget.getWizardData());
                  }
                } catch {}
              } catch {}
            };
            extras.push(
              <Button key="form-populate" size="small" loading={openAI.loading} onClick={handlePopulateForm}
                style={{ backgroundColor: 'hsl(var(--primary))', borderColor: 'hsl(var(--primary))', color: 'hsl(var(--primary-foreground))' }}>
                {(populateCfg && populateCfg.label) || 'Populate from AI'}
              </Button>
            );
          }
          // NOTE: Section-level grid populate removed for consistency.
          // All grid population now handled at widget level only (consistent with ai-inspection-assistant.json)
          if (extras.length === 0) return null;
          return (<div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>{openAI.loading && (<span style={{ color: 'hsl(var(--muted-foreground))' }}>Generating...</span>)}{extras}</div>);
        })()}
        style={{ borderRadius: 'var(--radius)', marginTop: 8, marginBottom: 12 }}
        headStyle={{ padding: '6px 10px' }}
        bodyStyle={{ padding: 8 }}
      >
        <div className="section-body">
        <Space direction="vertical" style={{ width: '100%' }} size={4}>
          {/* Removed custom resourcesGrid rendering - now uses standard grid pattern */}
           <Row gutter={[8, 8]}>
            {(section as any).sectionType === 'voice' && (
              <Col xs={24} md={12}>
                <Card className="glass-subcard" size="small" title={<span>Voice</span>} headStyle={{ padding: '6px 10px' }} bodyStyle={{ padding: 8 }}>
                  <div style={{ height: 200, overflow: 'auto' }}>
                    <VoiceRecorderWidget id={`voice-${sectionIndex}`} maxDuration={section.voice?.maxDuration ?? config.steps.input?.voice?.maxDuration} showVisualization={section.voice?.showVisualization ?? config.steps.input?.voice?.showVisualization} openaiConfig={getOpenAIConfig()} autoTranscribe value={(data as any).voiceData} onChange={(value) => updateSectionData(sectionIndex, { voiceData: value, textData: value?.transcription })} />
                  </div>
                </Card>
              </Col>
            )}
            {(section as any).sectionType === 'voice' && (
              <Col xs={24} md={12}>
                <Card className="glass-subcard" size="small" title={<span>Notes</span>} headStyle={{ padding: '6px 10px' }} bodyStyle={{ padding: 8 }}>
                  <Input.TextArea placeholder={section.text?.placeholder || `Enter notes for ${section.title}`} value={(data as any).textData} onChange={(e) => updateSectionData(sectionIndex, { textData: e.target.value })} rows={8} maxLength={section.text?.maxLength || 6000} showCount style={{ resize: 'none' }} />
                </Card>
              </Col>
            )}
          </Row>
          {(() => {
            const imagesCollapsed = Boolean(((wizardData.sections || [])[sectionIndex] as any)?.imagesCollapsed);
            return (section as any).sectionType === 'image' && !imagesCollapsed ? (
              <Card className="glass-subcard" size="small" title={<span>Images</span>} headStyle={{ padding: '6px 10px' }} bodyStyle={{ padding: 8 }}>
                <ImageUploadWithDrawingWidget id={`images-${sectionIndex}`} maxCount={section.images?.maxCount ?? config.steps.input?.images?.maxCount} maxSize={section.images?.maxSize ?? config.steps.input?.images?.maxSize} drawingEnabled={section.images?.drawingEnabled ?? config.steps.input?.images?.drawingEnabled} drawingTools={section.images?.drawingTools ?? config.steps.input?.images?.drawingTools} value={(data as any).images as any} onChange={(value) => updateSectionData(sectionIndex, { images: value as any })} />
              </Card>
            ) : null;
          })()}
          {/* Minimal flat form renderer when section defines groups */}
          {section.form?.groups && section.form.groups.length > 0 && (
            <>
              <Space direction="vertical" style={{ width: '100%' }}>
                <Form layout="vertical" className="form-underline">
                  <div className="group-grid">
                    {section.form.groups.map((group, gi) => {
                      const rawSpan = (group as any).lgSpan ?? 24; const span = Math.min(Math.max(Number(rawSpan), 1), 24);
                      return (
                        <div key={gi} className="group-grid-item" style={{ gridColumn: `span ${span}` }}>
                          <Card size="small" className="form-group-card glass-subcard" title={(group as any).title || (group as any).name || (group as any).id}>
                            <Row gutter={[12, 12]}>
                              {(group.fields || []).map((field) => {
                                  if (!field || !field.id) return null;
                                  const formData = (data as any).formData || {};
                                // Minimal: no dynamic showWhen logic; always render
                                const value = formData[field.id];
                                const updateField = (v: any) => {
                                  const currentFormData = (data as any).formData || {};
                                  const newFormData = { ...currentFormData, [field.id]: v };

                                  updateSectionData(sectionIndex, { formData: newFormData });
                                };
                                const isWide = field.type === 'textarea' || field.type === 'file' || field.type === 'static_checklist' || field.type === 'signature';
                                const lgSpan = (field as any).lgSpan ?? (isWide ? 24 : 12);
                                return (
                                  <Col key={field.id} xs={24} md={24} lg={lgSpan} xl={lgSpan}>
                                    <Form.Item label={field.label} required={field.required} labelCol={{ span: 24 }} wrapperCol={{ span: 24 }}>
                                      {field.type === 'text' && (<InputFieldWidget variant="underlined" value={value} onChange={updateField} />)}
                                      {field.type === 'number' && (<InputNumber value={value} onChange={updateField as any} style={{ width: '100%' }} />)}
                                      {field.type === 'date' && (<DatePickerWidget variant="underlined" value={value} onChange={updateField} />)}
                                      {field.type === 'textarea' && (<TextAreaWidget variant="underlined" value={value} onChange={updateField} />)}
                                      {field.type === 'signature' && (<SignatureWidget id={field.id} label={field.label} value={value} onChange={updateField} required={field.required} signedBy={user ? `${user.firstName} ${user.lastName}` : 'Unknown User'} {...(field.props || {})} />)}
                                      {field.type === 'dropdown' && (<ComboBoxWidget variant="underlined" value={value} onChange={updateField} options={(field.options || []).map((o: any) => typeof o === 'string' ? { label: o, value: o } : o)} />)}
                                      {(field.type as any) === 'select' && (
                                        <ComboBoxWidget
                                          variant="underlined"
                                          value={typeof value === 'object' && value?.value ? value.value : value}
                                          onChange={updateField}
                                          options={fieldOptions[field.id] || (field.options || []).map((o: any) => typeof o === 'string' ? { label: o, value: o } : o)}
                                          placeholder={(field as any).placeholder || (loadingOptions[field.id] ? 'Loading...' : 'Select...')}
                                          readOnly={(field as any).readonly}
                                          disabled={loadingOptions[field.id]}
                                        />
                                      )}
                                      {field.type === 'radio' && (<RadioWidget value={value} onChange={updateField} options={(field.options || []).map((o: any) => typeof o === 'string' ? { label: o, value: o } : o)} />)}
                                      {field.type === 'checkbox_group' && (<CheckboxWidget direction="horizontal" value={value || []} onChange={updateField} options={(field.options || []).map((o: any) => typeof o === 'string' ? { label: o, value: o } : o)} />)}
                                      {field.type === 'multi-select' && (<TagsInputWidget value={value || []} onChange={updateField} />)}
                                      {field.type === 'file' && (<UploadWidget onChange={({ fileList }) => updateField(fileList)} />)}
                                      {field.type === 'static_checklist' && (<div style={{ fontSize: 12, color: 'var(--ant-color-text)' }}>{(field.options || []).join(', ')}</div>)}
                                    </Form.Item>
                                  </Col>
                                );
                              })}
                            </Row>
                          </Card>
                        </div>
                      );
                    })}
                  </div>
                </Form>
              </Space>
            </>
          )}
          {/* Generic metadata-driven grid renderer */}
          {(section as any)?.grid && (() => {
            const gridCfg = (section as any).grid as any;
            const existingRows = ((data as any).formData?.[gridCfg.dataKey]) || [];
            // Optional default rows from another section (e.g., resources from image analysis)
            const defaultRows = (() => {
              try {
                const srcId = gridCfg.sourceSectionId as string | undefined;
                if (!srcId) return [];
                const srcIdx = (sections || []).findIndex(s => (s as any)?.id === srcId);
                if (srcIdx < 0) return [];
                const src = ((wizardData.sections || [])[srcIdx] || {}) as any;
                const recs = src?.imageAnalysis?.suggestions || [];
                const ids = src?.imageAnalysis?.selectedSuggestionIds || [];
                const picked = (ids.length > 0
                  ? ids.map((id: string) => recs.find((r: any) => String(r.id) === String(id))).filter(Boolean)
                  : recs);
                // Flatten resources (id, name, type, quantity, notes) when present
                const rows = picked.flatMap((r: any, i: number) => (Array.isArray(r.resources) ? r.resources : []).map((res: any, j: number) => ({
                  id: String(res.id || `${i}-${j}`),
                  name: String(res.name || ''),
                  type: res.type ? String(res.type) : '',
                  quantity: res.quantity ?? '',
                  notes: res.notes ? String(res.notes) : ''
                })));
                return rows;
              } catch { return []; }
            })();
            const rows = (existingRows && existingRows.length > 0) ? existingRows : defaultRows;
            const setRows = (rowsNext: any[]) => updateSectionData(sectionIndex, { formData: { ...((data as any).formData || {}), [gridCfg.dataKey]: rowsNext } });
            const handlePopulate = async () => {
              try {
                // Build context automatically: transcript and best image overview
                const transcript = [
                  wizardData.voiceData?.transcription || '',
                  wizardData.textData || '',
                  ...((wizardData.sections || []).flatMap(s => [s.voiceData?.transcription || '', (s as any)?.textData || '']))
                ].filter(Boolean).join('\n\n');
                const findAnalysisIdx = () => {
                  const byId = (sections || []).findIndex(s => (s as any)?.id === 'image_analysis');
                  if (byId >= 0) return byId;
                  return (wizardData.sections || []).findIndex(s => Boolean((s as any)?.imageAnalysis?.overview));
                };
                const anaIdx = findAnalysisIdx();
                const src = ((wizardData.sections || [])[anaIdx] || {}) as any;
                const imageOverview = String(src?.imageAnalysis?.overview || '');
                const selected = (src.imageAnalysis?.selectedSuggestionIds || []).map((id: string) => (src.imageAnalysis?.suggestions || []).find((r: any) => String(r.id) === String(id))).filter(Boolean);
                const selectedRecommendations = selected.map((r: any) => ({ label: r.label, priority: r.priority, category: r.category }));
                const promptRef: string | undefined = gridCfg.promptRef || gridCfg?.populate?.promptRef;
                const deep = promptRef ? (config as any)?.prompts?.[promptRef] : undefined;
                if (!deep || !deep.promptConfig) { message.warning('Grid prompt not configured'); return; }
                const template = String(deep.promptConfig.userPrompt || '');
                // Build schema dynamically from grid columns (structure only)
                const itemSchema: any = {};
                (gridCfg.columns || []).forEach((cm: any) => { itemSchema[cm.key] = 'string'; });
                const schemaFields = { rows: [itemSchema] };
                 const autoGridBodyTemplate = () => {
                   const cols = (gridCfg.columns || []).map((c: any) => String(c.key));
                   const colConstraints = (gridCfg.columns || [])
                     .filter((c: any) => c.type || c.options)
                     .map((c: any) => {
                       if (c.options && Array.isArray(c.options)) {
                         return `${c.key}: must be one of ${JSON.stringify(c.options)}`;
                       } else if (c.type === 'boolean' || c.type === 'yesno') {
                         return `${c.key}: use "Yes" or "No"`;
                       } else if (c.type === 'number') {
                         return `${c.key}: use numeric values`;
                       }
                       return null;
                     })
                     .filter(Boolean)
                     .join(', ');
                   
                   // Determine desired row count (can be provided from metadata, otherwise default)
                   const desiredRows: number = Number((gridCfg as any)?.desiredRows) || 10;
                   const maxRows: number = Math.max(desiredRows + 5, desiredRows);
                   
                   const generatedTemplate = [
                     `Generate tabular data for columns: ${JSON.stringify(cols)}.`,
                     colConstraints ? `Constraints: ${colConstraints}.` : '',
                     `Return a JSON array of ${desiredRows}â€“${maxRows} objects (one object per row) using exactly those keys.`,
                     'Prioritize diverse, realistic values across rows; avoid duplicates when possible.',
                     'For unknowns, you may use "N/A" for strings and 0 for numbers.',
                     'Example (illustrative only): [{"name": "Item1", "type": "Type1"}, {"name": "Item2", "type": "Type2"}]'
                   ].filter(Boolean).join(' ');
                   
                   console.debug('[Grid Auto-Template Generated]', {
                     cols,
                     colConstraints,
                     generatedTemplate
                   });
                   
                   return generatedTemplate;
                 };
                 const templateBodyUse = (!template || (deep as any)?.autoPrompt === true) ? autoGridBodyTemplate() : template;
                 
                 console.debug('[Grid Auto-Template]', {
                   gridId: gridCfg.dataKey,
                   promptRef: gridCfg.promptRef,
                   hasTemplate: Boolean(template),
                   autoPrompt: (deep as any)?.autoPrompt,
                   usingAutoGenerated: (!template || (deep as any)?.autoPrompt === true),
                   generatedTemplate: templateBodyUse.substring(0, 100) + '...'
                 });
                 const filledUser = buildPromptText(templateBodyUse, {
                   mapping: (deep as any)?.mapping,
                   context: {
                     selected_recommendations_json: selectedRecommendations,
                     schema_fields_json: schemaFields,
                     fill_unknown_with: 'N/A'
                   }
                 });
                const prevId = (wizardData as any)?.analysisData?.previousResponseId || (window as any)?.__previousResponseId;
                const requestParams = {
                  text: filledUser,
                  modelConfig: {
                    ...((deep?.modelConfig as any) || {}),
                    maxCompletionTokens: Math.max(((deep?.modelConfig as any)?.maxCompletionTokens ?? 0), 2500)
                  },
                  promptConfig: { systemPrompt: deep?.promptConfig?.systemPrompt || '', userPrompt: '{text}' },
                  responseFormat: 'json' as const,
                  store: true,
                  previousResponseId: typeof prevId === 'string' ? prevId : undefined,
                  reasoningEffort: 'low' as const
                };
                
                try {
                  console.log('[Grid Populate] Request params:', {
                    responseFormat: requestParams.responseFormat,
                    modelConfig: requestParams.modelConfig,
                    hasSystemPrompt: Boolean(requestParams.promptConfig.systemPrompt),
                    hasPreviousResponseId: Boolean(requestParams.previousResponseId),
                    fullParams: requestParams
                  });
                } catch {}
                
                const response = await openAI.respond(requestParams);
                try { 
console.log('[Grid Populate] Section ID:', section.id);
console.log('[Grid Populate] Prompt ref:', promptRef);
// Check for truncation or completion issues
                  const isIncomplete = (response as any)?.incomplete_details?.reason;
                  if (isIncomplete) {
                    console.error('[Grid Populate] Response was incomplete!', {
                      reason: isIncomplete,
                      maxTokens: (deep?.modelConfig as any)?.maxCompletionTokens,
                      usage: (response as any)?.usage
                    });
                  }
                } catch {}
                // Check if response was truncated
                const responseText = String(response.data || '');
                const isTruncated = !responseText.trim().endsWith(']') && !responseText.trim().endsWith('}');
                if (isTruncated) {
                  console.warn('[Grid Populate] Response appears truncated:', {
                    length: responseText.length,
                    endsWith: responseText.slice(-50),
                    tokenLimit: (deep?.modelConfig as any)?.maxCompletionTokens || 'unknown'
                  });
                }
                
                // Robustly extract an array of rows from varied LLM response shapes
                const tryParseJson = (str: string): any | null => { try { return JSON.parse(str); } catch { return null; } };
                const stripCodeFences = (s: string): string => s.replace(/^```[a-z]*\n?/i, '').replace(/\n?```$/i, '').trim();
                const extractFirstJson = (s: string): any | null => {
                  // Prefer fenced JSON blocks first
                  const fenced = s.match(/```(?:json)?[\s\S]*?```/i);
                  if (fenced) {
                    const inner = stripCodeFences(fenced[0]);
                    const parsed = tryParseJson(inner);
                    if (parsed) return parsed;
                  }
                  // Prefer arrays before objects to satisfy "Return ONLY JSON array" instructions
                  const arrMatch = s.match(/\[[\s\S]*\]/);
                  if (arrMatch) {
                    const parsed = tryParseJson(arrMatch[0]);
                    if (parsed) return parsed;
                    // Try to fix truncated JSON array by closing it
                    if (isTruncated && arrMatch[0].includes('{')) {
                      const fixedJson = arrMatch[0].replace(/,\s*$/, '') + ']';
                      const fixed = tryParseJson(fixedJson);
                      if (fixed) {
                        console.warn('[Grid Populate] Fixed truncated JSON array');
                        return fixed;
                      }
                    }
                  }
                  // If an object is found, ignore pure error wrappers and continue searching
                  const objMatch = s.match(/\{[\s\S]*\}/);
                  if (objMatch) {
                    const parsed = tryParseJson(objMatch[0]);
                    if (parsed && typeof parsed === 'object') {
                      const keys = Object.keys(parsed);
                      const isErrorOnly = keys.length === 1 && (keys[0] === 'error' || keys[0] === 'message');
                      if (!isErrorOnly) return parsed;
                    }
                  }
                  return null;
                };
                let result: any = response.data || {};
                if (typeof result === 'string') {
                  // Direct JSON string or text with JSON inside
                  result = tryParseJson(result) ?? extractFirstJson(result) ?? {};
                }
                if (result && typeof result.content === 'string') {
                  // Some providers wrap JSON in a 'content' field
                  const inner = tryParseJson(result.content) ?? extractFirstJson(result.content);
                  if (inner) result = inner;
                }
                // Defensive: handle when the entire raw chat response was forwarded
                const contentStr = (result as any)?.choices?.[0]?.message?.content;
                if (typeof contentStr === 'string') {
                  const inner = tryParseJson(contentStr) ?? extractFirstJson(contentStr);
                  if (inner) result = inner;
                }
                // As a final fallback, try any rawText attached by caller
                if (!result || (typeof result === 'object' && Object.keys(result).length === 0)) {
                  const raw = (response as any)?.rawText || '';
                  const inner = extractFirstJson(raw);
                  if (inner) result = inner;
                }
                try { console.log('[Grid Populate] parsed result type:', Array.isArray(result) ? 'array' : typeof result, 'keys:', (result && typeof result==='object') ? Object.keys(result) : 'n/a'); } catch {}
                // Normalize to an array for grid ingestion
                let list: any[] = Array.isArray(result) ? result : [];
                // If the model returned an object with an array property (e.g., { personnel: [...] }),
                // select the array using the metadata dataKey or the first array found.
                if (!Array.isArray(result) && result && typeof result === 'object') {
                  // Use metadata dataKey if it points to an array, else take the first array found
                  const keyFromMeta = gridCfg?.dataKey as string | undefined;
                  if (keyFromMeta && Array.isArray((result as any)[keyFromMeta])) {
                    list = (result as any)[keyFromMeta];
                  } else {
                    const firstArrayKey = Object.keys(result).find(k => Array.isArray((result as any)[k]));
                    if (firstArrayKey) list = (result as any)[firstArrayKey];
                    try { console.log('[Grid Populate] keyFromMeta:', keyFromMeta, 'firstArrayKey:', firstArrayKey); } catch {}
                  }
                }
                
                console.debug('[Grid Populate] After dataKey processing:', {
                  listType: Array.isArray(list) ? 'array' : typeof list,
                  listLength: Array.isArray(list) ? list.length : 'n/a',
                  resultType: Array.isArray(result) ? 'array' : typeof result,
                  willCheckFallback: !Array.isArray(list)
                });

                // If we received fewer rows than desired, attempt continuation calls to extend the list
                try {
                  const desiredRows: number = Number((gridCfg as any)?.desiredRows) || 10;
                  const hasFewRows = Array.isArray(list) && list.length < desiredRows;
                  if (hasFewRows) {
                    const cols = (gridCfg.columns || []).map((c: any) => String(c.key));
                    let combined: any[] = Array.isArray(list) ? list.slice() : [];
                    const maxContinuations = 3;
                    let attempts = 0;
                    let prevResponseId = (response as any)?.responseId || (window as any)?.__previousResponseId;
                    while (combined.length < desiredRows && attempts < maxContinuations) {
                      const remaining = Math.max(1, desiredRows - combined.length);
                      const continueTemplate = [
                        'Continue the previous grid generation.',
                        `Provide ${remaining} additional row(s) only.`,
                        `Use the same columns: ${JSON.stringify(cols)}.`,
                        'Return a JSON array of objects; do not repeat earlier rows.'
                      ].join(' ');
                      const continueText = buildPromptText(continueTemplate, { mapping: (deep as any)?.mapping, context: {} });
                      const contResp = await openAI.respond({
                        modelConfig: {
                          ...((deep?.modelConfig as any) || {}),
                          maxCompletionTokens: Math.max(((deep?.modelConfig as any)?.maxCompletionTokens ?? 0), 2500)
                        },
                        promptConfig: { systemPrompt: deep?.promptConfig?.systemPrompt || '', userPrompt: '{text}' },
                        text: continueText,
                        store: true,
                        previousResponseId: typeof prevResponseId === 'string' ? prevResponseId : undefined,
                        responseFormat: 'json',
                        reasoningEffort: 'high'
                      });
                      prevResponseId = (contResp as any)?.responseId || prevResponseId;
                      let more: any = contResp.data || {};
                      if (typeof more === 'string') more = tryParseJson(more) ?? extractFirstJson(more) ?? {};
                      if (more && typeof more.content === 'string') {
                        const inner = tryParseJson(more.content) ?? extractFirstJson(more.content);
                        if (inner) more = inner;
                      }
                      // Normalize continuation payload into array
                      let moreList: any[] = Array.isArray(more) ? more : [];
                      if (!Array.isArray(more) && more && typeof more === 'object') {
                        const keyFromMeta = gridCfg?.dataKey as string | undefined;
                        if (keyFromMeta && Array.isArray((more as any)[keyFromMeta])) {
                          moreList = (more as any)[keyFromMeta];
                        } else {
                          const firstArrayKey = Object.keys(more).find(k => Array.isArray((more as any)[k]));
                          if (firstArrayKey) moreList = (more as any)[firstArrayKey];
                        }
                      }
                      // Merge and de-duplicate by signature of key fields
                      const keyFields: string[] = (gridCfg.columns || []).map((cm: any) => cm.key);
                      const toSignature = (item: any) => keyFields.map(k => String((item || {})[k] ?? '')).join('|');
                      const seen = new Set<string>(combined.map(toSignature));
                      const filtered = (Array.isArray(moreList) ? moreList : []).filter((it: any) => {
                        const sig = toSignature(it);
                        if (seen.has(sig)) return false;
                        seen.add(sig);
                        return true;
                      });
                      if (filtered.length === 0) break;
                      combined = combined.concat(filtered);
                      attempts += 1;
                    }
                    list = combined;
                  }
                } catch {}
                
                // Final fallback: if we still don't have a populated array but have a valid object with the right keys,
                // treat it as a single-item array (common AI mistake despite array instructions)
                if ((!Array.isArray(list) || list.length === 0) && result && typeof result === 'object' && Object.keys(result).length > 0) {
                  const expectedKeys = (gridCfg.columns || []).map((c: any) => c.key);
                  const resultKeys = Object.keys(result);
                  const hasExpectedKeys = expectedKeys.some((key: string) => resultKeys.includes(key));
                  
                  const shouldExpectMultipleFallback = true; // All grids expect multiple rows
                  
                  console.debug('[Grid Populate] Fallback check:', {
                    expectedKeys,
                    resultKeys,
                    hasExpectedKeys,
                    resultType: typeof result,
                    isArray: Array.isArray(result),
                    gridTitle: gridCfg.title,
                    shouldExpectMultipleRows: shouldExpectMultipleFallback,
                    expectedRowsRange: shouldExpectMultipleFallback ? '2-50+ rows depending on scenario complexity' : '1+ rows'
                  });
                  
                  if (hasExpectedKeys) {
                    const shouldExpectMultiple = true; // All grids expect multiple rows
                    
                    if (shouldExpectMultiple) {
                      console.error('[Grid Populate] AI returned single object for grid that should have multiple rows!', {
                        gridTitle: gridCfg.title,
                        singleObject: result,
                        recommendAction: 'This suggests the AI prompt needs improvement or token limit is too low'
                      });
                    }
                    
                    console.warn('[Grid Populate] AI returned single object instead of array, converting to single-item array:', result);
                    list = [result];
                  } else {
                    // Even more aggressive fallback: if it's a non-empty object and we have no array,
                    // and it's not clearly a wrapper object, treat it as a grid row
                    const isPotentialGridRow = Object.keys(result).length > 1 && 
                                              !result.hasOwnProperty('data') && 
                                              !result.hasOwnProperty('rows') &&
                                              !result.hasOwnProperty('items');
                    if (isPotentialGridRow) {
                      console.warn('[Grid Populate] Aggressive fallback: treating object as single grid row:', result);
                      list = [result];
                    }
                  }
                }
                
                // Handle AI refusal/error responses
                if (result && typeof result === 'object' && result.hasOwnProperty('error')) {
                  console.warn('[Grid Populate] AI returned error response:', result.error);
                  message.warning(`AI Error: ${result.error}`);
                  return;
                }
                
                try { console.log('[Grid Populate] selected array length:', Array.isArray(list) ? list.length : 0); } catch {}
                if (!Array.isArray(list) || list.length === 0) {
                  message.warning('AI returned no rows to populate.');
                  return;
                }
                // Generic row mapping based on columns
                const resolveValueBody = (item: any, cm: any) => {
                  const candidates: string[] = [];
                  if (typeof cm.sourceKey === 'string') candidates.push(cm.sourceKey);
                  if (Array.isArray(cm.sourceKeys)) candidates.push(...cm.sourceKeys);
                  candidates.push(cm.key);
                  let value: any = undefined;
                  for (const key of candidates) {
                    const v = (item as any)[key];
                    if (v !== undefined) { value = v; break; }
                  }
                  if (value === undefined) {
                    if (/^(notes?|remarks?|comments?)$/i.test(String(cm.key))) {
                      for (const alt of ['notes', 'note', 'remarks', 'remark', 'comment', 'comments', 'summary']) {
                        if ((item as any)[alt] !== undefined) { value = (item as any)[alt]; break; }
                      }
                    }
                  }
                  if (Array.isArray(value)) return value.join(', ');
                  return value ?? '';
                };
                const rowsMapped = (list as any[]).map((item: any, i: number) => {
                  const row: any = { id: String((item as any).id || i) };
                  (gridCfg.columns || []).forEach((cm: any) => { row[cm.key] = resolveValueBody(item, cm); });
                  return row;
                });
                const keyFieldsBody: string[] = (gridCfg.columns || []).map((cm: any) => cm.key);
                const seenBody = new Set<string>();
                const rowsNext = rowsMapped.filter((row: any) => {
                  const sig = keyFieldsBody.map(k => String(row[k] ?? '')).join('|');
                  if (seenBody.has(sig)) return false;
                  seenBody.add(sig);
                  return true;
                });
                setRows(rowsNext);
                try { console.log('[Grid Populate] mapped rows:', rowsNext.length, 'sample:', rowsNext[0]); } catch {}
                message.success(`Populated ${rowsNext.length} row(s)`);
                // Database persistence is handled by useInspectionSave hook
              } catch {}
            };
            // Smart summary based on column meta
            const cols = Array.isArray(gridCfg.columns) ? gridCfg.columns : [];
            const coerceNumberFn = (v: any) => coerceNumberUtil(v);
            const buildSummaryWidgets = () => {
              return buildGridSummaryWidgets(rows as any, cols as any);
            };
            const populateButton = (gridCfg.promptRef || gridCfg?.populate?.promptRef) ? (
              <Button 
                key="grid-populate" 
                size="small" 
                loading={openAI.loading} 
                onClick={handlePopulate}
                style={{ backgroundColor: 'hsl(var(--primary))', borderColor: 'hsl(var(--primary))', color: 'hsl(var(--primary-foreground))' }}
              >
                {gridCfg.btnLabel || gridCfg.populateLabel || gridCfg.populate?.label || 'Populate from AI'}
              </Button>
            ) : null;
            
            return (
              <Card className="glass-subcard" size="small" title={<span>{gridCfg.title || 'Grid'}</span>} extra={populateButton} headStyle={{ padding: '6px 10px' }} bodyStyle={{ padding: 8 }}>
                {(() => {
                  const widgets = buildSummaryWidgets();
                  if (widgets.length === 0) return null;
                  return (
                    <div className="analysis-stats" style={{ marginBottom: 12 }}>
                      {widgets.map((w, i) => (
                        <div key={i} className="stat-card">
                          <div className="stat-title">{w.title || ''}</div>
                          <div className="stat-value">{String(w.value)}</div>
                          {w.description && (<div className="stat-desc">{w.description}</div>)}
                        </div>
                      ))}
                    </div>
                  );
                })()}
                {/* header extra now hosts populate; remove in-body duplicate */}
                <React.Suspense fallback={null}>
                  <EditableGridWidget
                    rows={rows}
                    onChange={setRows}
                    columnsMeta={gridCfg.columns}
                    features={gridCfg.features}
                  />
                </React.Suspense>
              </Card>
            );
          })()}
          {(() => {
            const explicit = (section as any).imageAnalysisPrompt;
            const refName = (section as any).imageAnalysisPromptRef
              || (((section as any).id === 'image_analysis') ? (section as any).promptRef : undefined);
            if (!refName && !explicit) return null;
            const promptCfg = explicit || (refName ? (config as any)?.prompts?.[refName] : undefined);
            if (!promptCfg) return null;
            (section as any).imageAnalysisPrompt = normalizeVisionPromptConfig(promptCfg) as any;
            return (<SectionImageAnalysis sectionIndex={sectionIndex} />);
          })()}
        </Space>
        </div>
      </Card>
    );
  };

  const handleStepChange = useCallback((step: number) => { if (gadget.canNavigateToStep(step)) { setCurrentStep(step); gadget.navigateToStep(step); setWizardData(gadget.getWizardData()); } }, [gadget]);
  const handleDataUpdate = useCallback((data: Partial<AIAnalysisWizardData>) => { gadget.updateWizardData(data); setWizardData(gadget.getWizardData()); }, [gadget]);

  const { saveSectionProgress, inspectionId, setInspectionId } = useInspectionSave();
  
  const handleStepComplete = useCallback(() => {
    try {
      // Save to inspection database
      const saveInspection = async () => {
        const wizardData = gadget.getWizardData();
        const steps = (config as any).steps;
        const currentStepName = Object.keys(steps || {})[currentStep];
        
        if (currentStepName && wizardData) {
          // Build the complete form data from all sections
          const allFormData: any = {};
          
          // Collect data from all completed sections
          if (wizardData.sections && Array.isArray(wizardData.sections)) {
            wizardData.sections.forEach((section: any) => {
              if (section && section.fields) {
                Object.entries(section.fields).forEach(([key, value]) => {
                  allFormData[key] = value;
                });
              }
            });
          }
          
          // Extract equipment info from voice transcript or analysis
          const voiceTranscript = wizardData.voiceData?.transcription || '';
          
          // Try to extract from analysis results first, then form data, then defaults
          const analysisResults = wizardData.analysisData?.analysisResults || [];
          const firstAnalysis = analysisResults[0] || {};
          
          // Get inspection type from wizard metadata configuration
          const getInspectionTypeFromMetadata = () => {
            // Check if metadata has inspection type configuration
            const metadataInspectionType = (config as any)?.inspectionType || (config as any)?.equipmentType;
            if (metadataInspectionType) {
              return metadataInspectionType;
            }
            
            // Try to detect from workspace configuration
            const workspaceId = (config as any)?.id;
            if (workspaceId) {
              if (workspaceId.includes('pressure-vessel') || workspaceId.includes('tank')) return 'pressure_vessel';
              if (workspaceId.includes('pipework') || workspaceId.includes('piping')) return 'piping';
              if (workspaceId.includes('rotating-equipment')) return 'rotating_equipment';
              if (workspaceId.includes('heat-exchanger') || workspaceId.includes('boiler')) return 'heat_exchanger';
            }
            
            // Try to detect from detected equipment type in form data
            const detectedType = allFormData.detected_equipment_type || allFormData.detected_piping_type;
            if (detectedType) {
              if (detectedType.includes('pressure_vessel') || detectedType.includes('tank')) return 'pressure_vessel';
              if (detectedType.includes('piping') || detectedType.includes('process')) return 'piping';
              if (detectedType.includes('pump') || detectedType.includes('compressor') || detectedType.includes('turbine')) return 'rotating_equipment';
              if (detectedType.includes('exchanger') || detectedType.includes('boiler') || detectedType.includes('heater')) return 'heat_exchanger';
            }
            
            return 'inspection'; // Generic fallback
          };

          // Include essential fields in formData for dashboard display
          const enrichedFormData = {
            ...allFormData,
            equipmentId: allFormData.asset_id || allFormData.equipment_tag || allFormData.equipment_id || allFormData.circuit_number || '',
            equipmentType: allFormData.detected_equipment_type || getInspectionTypeFromMetadata(),
            inspectionDate: allFormData.inspection_date || new Date(),
            inspectorName: allFormData.inspector_name || getLoggedInUserName() || 'Unknown User',
            location: allFormData.location || ''
          };
          
          const sectionData = {
            sectionId: currentStepName,
            inspectionType: getInspectionTypeFromMetadata(), // Use inspection type directly from wizard metadata
            workspaceId: (config as any)?.id, // Store the wizard type for reopening
            isStepCompletion: true, // Flag to indicate this is step completion, not just progress save
            formData: enrichedFormData,
            sections: wizardData.sections || [],
            grids: {},
            aiAnalysis: {
              voice: wizardData.voiceData || {},
              images: wizardData.imageData || [],
              results: analysisResults,
              markdownReport: wizardData.analysisData?.markdownReport || '',
              transcription: voiceTranscript
            },
            attachments: wizardData.imageData?.map((img: any) => ({
              type: 'image',
              url: img.url || img,
              metadata: { uploadDate: new Date() }
            })) || [],
            wizardState: {
              currentStep,
              completedSteps: wizardData.completedSteps || [],
              inspectionType: wizardData.inspectionType || 'External'
            }
          };
          
          await saveSectionProgress(currentStepName, sectionData, wizardData);
}
      };
      
      saveInspection().catch((error) => {
        console.error('Failed to save inspection to database:', error);
      });
      
      // Legacy API persistence removed - using inspection database only
    } catch {}
    gadget.completeCurrentStep();
    const updatedData = gadget.getWizardData();
    setWizardData(updatedData);
    setCurrentStep(updatedData.currentStep);
  }, [gadget, config, currentStep, saveSectionProgress, getLoggedInUserName]);

  const renderInputStep = () => (
    <Card className="glass-card wizard-card" title={<span style={{ color: 'hsl(var(--foreground))' }}>{config.steps.input?.title}</span>}>
      <Space direction="vertical" style={{ width: '100%' }} size="large">
        <Form.Item label={<span style={{ color: 'hsl(var(--foreground))' }}>{config.typeLabel || 'Inspection Type'}</span>} required>
          <Select placeholder={config.typePlaceholder || 'Select inspection type'} value={wizardData.inspectionType} onChange={(value) => handleDataUpdate({ inspectionType: value })} style={{ width: '100%' }}>
            {config.steps.input?.inspectionTypes?.map(type => (<Option key={type.value} value={type.value}>{type.label}</Option>))}
          </Select>
        </Form.Item>
        <Row gutter={[16, 16]}>
          {config.steps.input?.voice?.enabled && (
            <Col xs={24} md={12}>
              <Card className="glass-subcard" title={<span style={{ color: 'hsl(var(--foreground))' }}>Voice Recording</span>} size="small" style={{ height: '280px' }}>
                <div style={{ height: '200px', overflow: 'auto', padding: 'var(--spacing-2)' }}>
                  <VoiceRecorderWidget id="voice-recorder" maxDuration={config.steps.input?.voice?.maxDuration as number} showVisualization={Boolean(config.steps.input?.voice?.showVisualization)} openaiConfig={getOpenAIConfig()} autoTranscribe={true} value={wizardData.voiceData} onChange={(value) => handleDataUpdate({ voiceData: value })} />
                </div>
              </Card>
            </Col>
          )}
          {config.steps.input?.text?.enabled && (
            <Col xs={24} md={12}>
              <Card className="glass-subcard" title={<span style={{ color: 'hsl(var(--foreground))' }}>Text Notes</span>} size="small" style={{ height: '280px' }}>
                <div style={{ height: '200px', display: 'flex', flexDirection: 'column', padding: 'var(--spacing-2)' }}>
                  <TextArea placeholder={config.steps.input?.text?.placeholder} value={wizardData.textData} onChange={(e) => handleDataUpdate({ textData: e.target.value })} rows={8} maxLength={config.steps.input?.text?.maxLength} showCount style={{ flex: 1, resize: 'none' }} />
                </div>
              </Card>
            </Col>
          )}
        </Row>
        {config.steps.input?.images?.enabled && (
          <Card className="glass-subcard" title={<span style={{ color: 'hsl(var(--foreground))' }}>Image Upload</span>} size="small">
            <React.Suspense fallback={null}>
            <ImageUploadWithDrawingWidget id="image-upload" maxCount={config.steps.input?.images?.maxCount as number} maxSize={config.steps.input?.images?.maxSize as number} drawingEnabled={Boolean(config.steps.input?.images?.drawingEnabled)} drawingTools={config.steps.input?.images?.drawingTools as any} value={wizardData.imageData} onChange={(value) => handleDataUpdate({ imageData: value })} />
            </React.Suspense>
          </Card>
        )}
        <Space>
          <Button type="primary" onClick={handleStepComplete} disabled={Boolean(config.steps.input) && (!wizardData.inspectionType)} style={{ backgroundColor: 'hsl(var(--primary))', borderColor: 'hsl(var(--primary))', color: 'hsl(var(--primary-foreground))' }}>Next</Button>
        </Space>
      </Space>
    </Card>
  );

  // Helper function to check if a section should be displayed based on conditional logic
  const shouldShowSection = useCallback((section: any) => {
    if (!section.watchField || !section.showWhen) return true;
    
    // Get the value of the watched field from all form data
    let watchedValue = '';
    try {
      for (const sectionData of Object.values(wizardData.sections || {})) {
        const formData = (sectionData as any)?.formData || {};
        if (formData.hasOwnProperty(section.watchField)) {
          watchedValue = formData[section.watchField] || '';
          break;
        }
      }
    } catch {}
    
    // Debug logging for conditional sections
    try {
      console.debug('[Conditional Section]', {
        sectionId: section.id,
        watchField: section.watchField,
        showWhen: section.showWhen,
        currentValue: watchedValue,
        shouldShow: watchedValue === section.showWhen,
        allFormData: Object.fromEntries(
          Object.values(wizardData.sections || {}).map((s: any, i) => [
            i, (s?.formData || {})
          ])
        )
      });
    } catch {}
    
    // Check if the condition is met
    return watchedValue === section.showWhen;
  }, [wizardData, wizardData.sections]);

  const visibleSections = useMemo(() => {
    console.debug('[Visible Sections] Re-evaluating...', {
      timestamp: new Date().toISOString().slice(11, -1),
      wizardDataSectionsCount: Object.keys(wizardData.sections || {}).length,
      detectedEquipmentType: Object.values(wizardData.sections || {}).find((s: any) => 
        s?.formData?.detected_equipment_type
      )?.formData?.detected_equipment_type || 'none'
    });
    
    const filtered = sections.filter(shouldShowSection);
    console.debug('[Visible Sections] Result:', {
      totalSections: sections.length,
      visibleSections: filtered.length,
      sectionIds: sections.map(s => s.id),
      visibleIds: filtered.map(s => s.id),
      conditionalSections: sections.filter(s => (s as any).watchField).map(s => ({
        id: s.id,
        watchField: (s as any).watchField,
        showWhen: (s as any).showWhen
      }))
    });
    return filtered;
  }, [sections, shouldShowSection, wizardData]);

  const finalStepIndex = useMemo(() => {
    return visibleSections.length + (config.steps.input ? 1 : 0);
  }, [visibleSections.length, config.steps.input]);

  const getIconForSection = useCallback((s: any): React.ReactNode => {
    const id = String((s?.id || '')).toLowerCase();
    const type = String((s?.sectionType || '')).toLowerCase();
    const size = { fontSize: '16px' } as const;
    if (type === 'voice' || id.includes('voice')) return <AudioOutlined style={size} />;
    if (type === 'image' || id.includes('image') || id.includes('nameplate')) return <FileImageOutlined style={size} />;
    if (id.includes('analysis')) return <SearchOutlined style={size} />;
    if (id.includes('general') || id.includes('information')) return <ProfileOutlined style={size} />;
    if (id.includes('scope') || id.includes('method')) return <ReadOutlined style={size} />;
    if (id.includes('nde')) return <ExperimentOutlined style={size} />;
    if (id.includes('condition') || id.includes('assessment')) return <AlertOutlined style={size} />;
    if (id.includes('thickness') || id.includes('measurement')) return <DashboardOutlined style={size} />;
    if (id.includes('evaluation') || id.includes('compliance')) return <SafetyCertificateOutlined style={size} />;
    if (id.includes('recommend')) return <BulbOutlined style={size} />;
    if (id.includes('attachment')) return <PaperClipOutlined style={size} />;
    if (id.includes('signoff') || id.includes('sign-off') || id.includes('sign')) return <CheckCircleOutlined style={size} />;
    return <FormOutlined style={size} />;
  }, []);

  const stepItems = useMemo(() => {
    const items = [] as Array<{ title: string; description?: string; icon: React.ReactNode }>;
    if (config.steps.input) items.push({ title: config.steps.input.title, description: config.steps.input.description, icon: <SolutionOutlined style={{ fontSize: '16px' }} /> });
    items.push(...visibleSections.map((s) => ({ title: s.title, description: s.description, icon: getIconForSection(s) })));
    items.push({ title: config.steps.pdf.title, description: config.steps.pdf.description, icon: <FileMarkdownOutlined style={{ fontSize: '16px' }} /> });
    return items;
  }, [visibleSections, config.steps.pdf, config.steps.input, getIconForSection]);

  const goPrev = useCallback(() => {
    const minIndex = 0;
    const prev = Math.max(minIndex, currentStep - 1);
    if (prev !== currentStep) handleStepChange(prev);
  }, [currentStep, handleStepChange]);

  const isAtLast = useMemo(() => {
    return (!config.steps.input && currentStep === visibleSections.length)
      || (config.steps.input && currentStep === visibleSections.length + 1);
  }, [currentStep, visibleSections.length, config.steps.input]);

  const renderBodyForCurrent = () => {
    // Map currentStep to actual section index from visible sections
    const getSectionIndex = (step: number) => {
      const adjustedStep = config.steps.input ? step - 1 : step;
      if (adjustedStep < 0 || adjustedStep >= visibleSections.length) return -1;
      
      // Find the index of this visible section in the original sections array
      const visibleSection = visibleSections[adjustedStep];
      return sections.findIndex(s => s.id === visibleSection.id);
    };

    const sectionIndex = getSectionIndex(currentStep);

    return (
    <>
      {config.steps.input && currentStep === 0 && renderInputStep()}
        {sectionIndex >= 0 && renderSectionStep(sectionIndex)}
        {(!config.steps.input && currentStep === visibleSections.length) && renderPdfStep()}
        {(config.steps.input && currentStep === visibleSections.length + 1) && renderPdfStep()}
    </>
  );
  };

  const menuItems = useMemo(() => {
    return stepItems.map((step, index) => {
      const isActive = currentStep === index;
      const isDone = wizardData.completedSteps.includes(index);
      const rightStatus = isDone ? 'âœ“' : (!isActive ? 'â€¢' : '');
      return {
        key: String(index),
        icon: step.icon as any,
        label: (
          <span style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', width: '100%' }}>
            <span>{step.title}</span>
            <span aria-hidden="true" style={{ color: isDone ? 'hsl(var(--primary))' : 'hsl(var(--muted-foreground))' }}>{rightStatus}</span>
          </span>
        )
      };
    });
  }, [stepItems, currentStep, wizardData.completedSteps]);

  return (
    <div className="ai-analysis-wizard" style={{ height: '100%', minHeight: 0, padding: 0 }}>
      {/* Professional Header */}
      <div className="wizard-header">
        <div>
          <h1 className="wizard-header__title">
            <FileMarkdownOutlined style={{ fontSize: '1.25rem' }} />
            {config.title || 'AI Inspection Assistant'}
          </h1>
          <p className="wizard-header__subtitle">
            {config.description || 'Intelligent inspection workflow with AI-powered analysis and documentation'}
          </p>
        </div>
        <div className="wizard-header__actions">
          <span style={{ fontSize: '0.875rem', color: 'hsl(var(--muted-foreground))' }}>
            Step {currentStep + 1} of {visibleSections.length}
          </span>
        </div>
      </div>

      <div className="wizard-doc-layout">
        <aside className="wizard-sidebar" role="navigation" aria-label="Wizard steps">
          <Layout style={{ height: '100%' }}>
            <Layout.Sider
              trigger={null}
              collapsible={false}
              width={280}
              theme="light"
              style={{
                height: '100%',
                background: 'hsl(var(--card))',
                borderRight: '1px solid hsl(var(--border))'
              }}
            >
              <div style={{ padding: '16px 0' }}>
                <Menu
                  mode="inline"
                  selectedKeys={[String(currentStep)]}
                  style={{
                    height: '100%',
                    borderRight: 0,
                    background: 'transparent',
                    color: 'hsl(var(--foreground))',
                    fontSize: '14px'
                  }}
                  items={menuItems}
                  onClick={({ key }) => handleStepChange(Number(key))}
                />
              </div>
            </Layout.Sider>
          </Layout>
        </aside>
        <main className="wizard-content" role="region" aria-label="Wizard content" style={{ height: '100%', minHeight: 0, overflow: 'auto' }}>
          {renderBodyForCurrent()}
        </main>
      </div>
      <div className="wizard-footer">
        <div className="wizard-footer-left">
          <span className="progress-indicator">
            {Math.round(gadget.getStepProgress())}% Complete
          </span>
          <span style={{
            fontSize: '0.75rem',
            color: 'hsl(var(--muted-foreground))',
            marginLeft: '8px'
          }}>
            Step {currentStep + 1} of {visibleSections.length}
          </span>
        </div>
        <div className="wizard-footer-actions">
          <Button
            onClick={goPrev}
            disabled={currentStep === 0}
            style={{
              border: '1px solid hsl(var(--border))',
              background: 'hsl(var(--card))',
              color: 'hsl(var(--foreground))'
            }}
          >
            â† Back
          </Button>
          <Button
            type="primary"
            onClick={handleStepComplete}
            style={{
              fontWeight: 600,
              padding: '6px 24px'
            }}
          >
            {isAtLast ? (
              <>
                <FormOutlined style={{ marginRight: '8px' }} />
                Complete Inspection
              </>
            ) : (
              <>
                Continue â†’
              </>
            )}
          </Button>
        </div>
      </div>
    </div>
  );

  function renderPdfStep() {
    // Build generic metadata-driven sections from wizard content
    const pdfStyling = (config.steps.pdf.reportConfig as any)?.pdfStyling;
    const contentSections: any[] = [];
    let order = 1;
    (sections || []).forEach((s, index) => {
      // Skip voice and raw image capture; allow vision analysis if metadata requests inclusion
      const isVoice = (s as any).sectionType === 'voice';
      const isImage = (s as any).sectionType === 'image';
      const isVision = Boolean((s as any).imageAnalysisPrompt);
      if (isVoice || isImage) return;
      // If it's the vision analysis section and includeInPdf is true, include overview and optional images
      if (isVision && (s as any).includeInPdf === true) {
        const pdfCfg = (s as any).pdf || {};
        const includeOverview = pdfCfg.includeOverview !== false;
        const includeImages = pdfCfg.includeImages === true;
        if (includeOverview) {
          const ov = String(((wizardData.sections || [])[index] as any)?.imageAnalysis?.overview || '');
          if (ov) {
            // Extract all Markdown tables and render them as PDF tables
            try {
              const tableRegex = /(^|\n)\|[^\n]+\|\n\|[\-:\|\s]+\|[\s\S]*?(?=\n\n|$)/g;
              const matches = ov.match(tableRegex) || [];
              matches.forEach((block: string, tIdx: number) => {
                try {
                  const lines = block.trim().split('\n').map(l => l.trim());
                  const headerCells = (lines[0] || '').split('|').map(s => s.trim()).filter(Boolean);
                  const rows = lines.slice(2).map(line => line.split('|').map(s => s.trim()).filter(Boolean)).filter(r => r.length === headerCells.length);
                  if (headerCells.length > 0 && rows.length > 0) {
                    const columns = headerCells.map((h, i) => ({ header: h, key: `c${i}` }));
                    const data = rows.map(r => Object.fromEntries(r.map((v, i) => [`c${i}`, v])));
                    contentSections.push({ id: String(s.id) + `:table-${tIdx}`, title: (s.title || 'Analysis') + ` (Table ${tIdx + 1})`, includeInPdf: true, order: order++, content: { type: 'table', columns, data } });
                  }
                } catch {}
              });
              // Remove tables from the narrative text to avoid duplication
              const cleaned = ov.replace(tableRegex, '').trim();
              if (cleaned) {
                contentSections.push({ id: String(s.id) + ':overview', title: s.title || 'Image Analysis', includeInPdf: true, order: order++, content: { type: 'text', template: cleaned } });
              }
            } catch {
              // Fallback: include raw text if parsing fails
              contentSections.push({ id: String(s.id) + ':overview', title: s.title || 'Image Analysis', includeInPdf: true, order: order++, content: { type: 'text', template: ov } });
            }
          }
        }
        if (includeImages) {
          // Prefer images from referenced capture section, else from this section's data
          const imagesDataPath = pdfCfg.imagesDataPath as string | undefined;
          let imgs: any[] = [];
          if (imagesDataPath) {
            try {
              // resolve path sections[sectionId].images
              const match = imagesDataPath.match(/^sections\[(.*?)\]\.images$/);
              if (match) {
                const secId = match[1];
                const secIdx = (sections || []).findIndex(ss => (ss as any)?.id === secId);
                if (secIdx >= 0) imgs = Array.isArray(((wizardData.sections || [])[secIdx] as any)?.images) ? (((wizardData.sections || [])[secIdx] as any)?.images) : [];
              }
            } catch {}
          }
          if (imgs.length === 0) {
            imgs = Array.isArray(((wizardData.sections || [])[index] as any)?.images) ? (((wizardData.sections || [])[index] as any)?.images) : [];
          }
          // Fallback: If no images found in sections, use the main imageData from the widget
          if (imgs.length === 0 && wizardData.imageData && wizardData.imageData.length > 0) {
            imgs = wizardData.imageData;
          }
          const mapped = (imgs || []).map((it: any) => ({
            url: it.url,
            name: it.name,
            drawingData: it.drawingData
          }));
          const content: any = { type: 'image', data: mapped };
          // Only set explicit width/height if provided; otherwise allow engine to use widthPercent/heightPx defaults
          if (Number.isFinite(Number(pdfCfg.imageWidth))) content.width = Number(pdfCfg.imageWidth);
          if (Number.isFinite(Number(pdfCfg.imageHeight))) content.height = Number(pdfCfg.imageHeight);
          if (pdfCfg.widthPercent !== undefined) content.widthPercent = pdfCfg.widthPercent;
          if (pdfCfg.heightPx !== undefined) content.heightPx = pdfCfg.heightPx;
          if (pdfCfg.fit) content.fit = pdfCfg.fit;
          if (pdfCfg.align) content.align = pdfCfg.align;
          contentSections.push({ id: String(s.id) + ':images', title: s.title || 'Image Analysis', includeInPdf: true, order: order++, content });
        }
        return;
      }

      const secData = ((wizardData.sections || [])[index] as any) || {};
      const title = s.title || s.id;
      // Prefer grid as table
      if ((s as any).grid) {
        const gridCfg = (s as any).grid as any;
        const existingRows = Array.isArray(secData.formData?.[gridCfg.dataKey]) ? secData.formData[gridCfg.dataKey] : [];
        // Fallback: derive rows from selected image analysis recommendations if none in formData
        const deriveRowsFromAnalysis = (): any[] => {
          try {
            const srcId = (s as any).resourcesFromSectionId || gridCfg.sourceSectionId || 'image_analysis';
            const srcIdx = (sections || []).findIndex(ss => (ss as any)?.id === srcId);
            if (srcIdx < 0) return [];
            const src = ((wizardData.sections || [])[srcIdx] || {}) as any;
            const recs = Array.isArray(src?.imageAnalysis?.suggestions) ? src.imageAnalysis.suggestions : [];
            const ids = Array.isArray(src?.imageAnalysis?.selectedSuggestionIds) ? src.imageAnalysis.selectedSuggestionIds : [];
            const picked = (ids.length > 0
              ? ids.map((id: string) => recs.find((r: any) => String(r.id) === String(id))).filter(Boolean)
              : recs);
            return picked.flatMap((r: any, i: number) => (Array.isArray(r.resources) ? r.resources : []).map((res: any, j: number) => ({
              id: String(res.id || `${i}-${j}`),
              name: String(res.name || ''),
              type: res.type ? String(res.type) : '',
              quantity: res.quantity ?? '',
              notes: res.notes ? String(res.notes) : ''
            })));
          } catch { return []; }
        };
        const rows = existingRows.length > 0 ? existingRows : deriveRowsFromAnalysis();
        const columns = (gridCfg.columns || []).map((c: any) => ({ header: c.title || c.key, key: c.key }));
        contentSections.push({ id: String(s.id), title, includeInPdf: true, order: order++, content: { type: 'table', columns, data: rows } });
        return;
      }
      // Render forms either as grid (label on top), variable-span grid honoring field spans, or as labeled text
      if ((s as any).form?.groups && (s as any).form.groups.length > 0) {
        const formData = secData.formData || {};
        const pdfLayout = (s as any).pdfLayout;
        const allFields: any[] = [];
        (s as any).form.groups.forEach((g: any) => { (g.fields || []).forEach((f: any) => allFields.push(f)); });
        if (pdfLayout && String(pdfLayout.type) === 'grid') {
          const columnsCount = Math.max(1, Number(pdfLayout.columns || 4));
          // Provide structured items for PDF widget label-top grid rendering
          const items: Array<{ label: string; value: string }> = allFields.map((f: any) => {
            const raw = formData[f.id];
            const val = Array.isArray(raw) ? raw.join(', ') : (raw == null ? '' : String(raw));
            const label = String(f.label || f.id);
            return { label, value: val };
          });
          contentSections.push({ id: String(s.id), title, hideHeader: (s as any).hideHeaderInPdf === true, includeInPdf: true, order: order++, content: { type: 'labelTopGrid', columnsCount, items, labelValueSpacing: 2, gap: 4, cellPadding: 2 } });
        } else if (!pdfLayout || String(pdfLayout.type || '') === '') {
          // No pdfLayout: honor field spans to create a variable-span grid
          // Convert fields into rows totaling 24 units using their lgSpan or default 12
          const rows: Array<Array<{ label: string; value: string; span: number }>> = [];
          let currentRow: Array<{ label: string; value: string; span: number }> = [];
          let used = 0;
          const pushRow = () => { if (currentRow.length > 0) { rows.push(currentRow); currentRow = []; used = 0; } };
          for (const f of allFields) {
            const span = Math.min(24, Math.max(1, Number((f as any).lgSpan ?? ((f as any).type === 'textarea' ? 24 : 12))));
            const raw = formData[f.id];
            
            // Handle different field types properly
            let val: string;
            if ((f as any).type === 'signature' && typeof raw === 'object' && raw?.dataURL) {
              const signedBy = raw.signedBy || 'Unknown';
              const timestamp = raw.timestamp ? new Date(raw.timestamp).toLocaleString() : 'Unknown time';
              val = `Digitally signed by: ${signedBy} on ${timestamp}`;
            } else if ((f as any).type === 'select' && typeof raw === 'object' && raw?.label) {
              // Handle select field objects with label/value structure
              val = raw.label || raw.value || String(raw);
            } else if (Array.isArray(raw)) {
              // Handle arrays (multiselect, checkbox groups, etc.)
              val = raw.map(item => typeof item === 'object' && item?.label ? item.label : String(item)).join(', ');
            } else if (typeof raw === 'object' && raw !== null) {
              // Handle other objects - try to extract meaningful display value
              if (raw.label) val = raw.label;
              else if (raw.value) val = String(raw.value);
              else if (raw.name) val = raw.name;
              else if (raw.title) val = raw.title;
              else val = 'N/A';
            } else {
              val = raw == null ? '' : String(raw);
            }
            
            const cell = { label: String(f.label || f.id), value: String(val), span };
            if (used + span > 24) { pushRow(); }
            currentRow.push(cell); used += span;
            if (used === 24) { pushRow(); }
          }
          pushRow();
          contentSections.push({ id: String(s.id), title, hideHeader: (s as any).hideHeaderInPdf === true, includeInPdf: true, order: order++, content: { type: 'formGrid', rows } });
        } else {
          // Fallback: labeled text block (include fields even when value is empty)
          const lines: string[] = [];
          allFields.forEach((f: any) => {
            const raw = formData[f.id];
            
            // Handle different field types properly
            let val: string;
            if ((f as any).type === 'signature' && typeof raw === 'object' && raw?.dataURL) {
              const signedBy = raw.signedBy || 'Unknown';
              const timestamp = raw.timestamp ? new Date(raw.timestamp).toLocaleString() : 'Unknown time';
              val = `Digitally signed by: ${signedBy} on ${timestamp}`;
            } else if ((f as any).type === 'select' && typeof raw === 'object' && raw?.label) {
              // Handle select field objects with label/value structure
              val = raw.label || raw.value || String(raw);
            } else if (Array.isArray(raw)) {
              // Handle arrays (multiselect, checkbox groups, etc.)
              val = raw.map(item => typeof item === 'object' && item?.label ? item.label : String(item)).join(', ');
            } else if (typeof raw === 'object' && raw !== null) {
              // Handle other objects - try to extract meaningful display value
              if (raw.label) val = raw.label;
              else if (raw.value) val = String(raw.value);
              else if (raw.name) val = raw.name;
              else if (raw.title) val = raw.title;
              else val = 'N/A';
            } else {
              val = raw == null ? '' : String(raw);
            }
            
            lines.push(`${f.label || f.id}: ${val}`);
          });
          const template = lines.join('\n');
          contentSections.push({ id: String(s.id), title, includeInPdf: true, order: order++, content: { type: 'text', template } });
        }
      }
    });

    const companyName = (pdfStyling as any)?.header?.companyName || 'intelliSPEC';
    const companyAddress = (pdfStyling as any)?.header?.companyAddress || '';
    const pdfMetadata = { header: { title: String(config.steps.pdf.title || config.title || 'Report'), companyName, companyAddress }, pdfStyling, sections: contentSections } as any;

    // Minimal header info; widget will use defaults for missing fields
    const valueForPdf = {
      reportTitle: String(config.steps.pdf.title || config.title || 'Report'),
      location: '',
      inspectorName: '',
      inspectorId: '',
      inspectionDate: '',
      inspectionTime: '',
      template: 'standard'
    } as any;

    return (
      <Card className="glass-card wizard-card pdf-step" title={<span>{config.steps.pdf.title}</span>}>
        <React.Suspense fallback={null}>
          <PDFGeneratorWidget
            id={config.steps.pdf.id || 'pdf-generator'}
            metadata={pdfMetadata}
            gadgetData={valueForPdf}
          />
        </React.Suspense>
      </Card>
    );
  }
};

export default AIAnalysisWizardGadget;